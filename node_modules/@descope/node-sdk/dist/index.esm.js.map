{"version":3,"file":"index.esm.js","sources":["../lib/fetch-polyfill.ts","../lib/helpers.ts","../lib/constants.ts","../lib/management/paths.ts","../lib/management/user.ts","../lib/management/project.ts","../lib/management/tenant.ts","../lib/management/jwt.ts","../lib/management/permission.ts","../lib/management/role.ts","../lib/management/group.ts","../lib/management/sso.ts","../lib/management/accesskey.ts","../lib/management/flow.ts","../lib/management/theme.ts","../lib/management/audit.ts","../lib/management/authz.ts","../lib/management/ssoapplication.ts","../lib/management/password.ts","../lib/management/fga.ts","../lib/errors.ts","../lib/index.ts","../lib/management/index.ts"],"sourcesContent":["import { fetch as crossFetch, Headers } from 'cross-fetch';\n\nglobalThis.Headers ??= Headers;\n\nconst highWaterMarkMb = 1024 * 1024 * 30; // 30MB\n\n// we are increasing the response buffer size due to an issue where node-fetch hangs when response is too big\nconst patchedFetch = (...args: Parameters<typeof crossFetch>) => {\n  // we can get Request on the first arg, or RequestInfo on the second arg\n  // we want to make sure we are setting the \"highWaterMark\" so we are doing it on both args\n  args.forEach((arg) => {\n    // Updated to only apply highWaterMark to objects, as it can't be applied to strings (it breaks it)\n    if (arg && typeof arg === 'object') {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-unused-expressions\n      (arg as any).highWaterMark ??= highWaterMarkMb;\n    }\n  });\n\n  return crossFetch(...args);\n};\n\nexport default patchedFetch as unknown as typeof fetch;\n","import type { SdkFnWrapper } from '@descope/core-js-sdk';\nimport { authorizedTenantsClaimName, refreshTokenCookieName } from './constants';\nimport { AuthenticationInfo } from './types';\n\n/**\n * Generate a cookie string from given parameters\n * @param name name of the cookie\n * @param value value of cookie that must be already encoded\n * @param options any options to put on the cookie like cookieDomain, cookieMaxAge, cookiePath\n * @returns Cookie string with all options on the string\n */\nconst generateCookie = (name: string, value: string, options?: Record<string, string | number>) =>\n  `${name}=${value}; Domain=${options?.cookieDomain || ''}; Max-Age=${\n    options?.cookieMaxAge || ''\n  }; Path=${options?.cookiePath || '/'}; HttpOnly; SameSite=Strict`;\n\n/**\n * Parse the cookie string and return the value of the cookie\n * @param cookie the raw cookie string\n * @param name the name of the cookie to get value for\n * @returns the value of the given cookie\n */\nconst getCookieValue = (cookie: string | null | undefined, name: string) => {\n  const match = cookie?.match(RegExp(`(?:^|;\\\\s*)${name}=([^;]*)`));\n  return match ? match[1] : null;\n};\n\n// eslint-disable-next-line import/prefer-default-export\n/**\n * Add cookie generation to core-js functions.\n * @param fn the function we are wrapping\n * @returns Wrapped function with cookie generation\n */\nexport const withCookie: SdkFnWrapper<{ refreshJwt?: string; cookies?: string[] }> =\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n\n    // istanbul ignore next\n    if (!resp.data) {\n      return resp;\n    }\n\n    // eslint-disable-next-line prefer-const\n    let { refreshJwt, ...rest } = resp.data;\n    const cookies: string[] = [];\n\n    if (!refreshJwt) {\n      if (resp.response?.headers.get('set-cookie')) {\n        refreshJwt = getCookieValue(\n          resp.response?.headers.get('set-cookie'),\n          refreshTokenCookieName,\n        );\n        cookies.push(resp.response?.headers.get('set-cookie')!);\n      }\n    } else {\n      cookies.push(generateCookie(refreshTokenCookieName, refreshJwt, rest));\n    }\n\n    return { ...resp, data: { ...resp.data, refreshJwt, cookies } };\n  };\n\n/**\n * Get the claim (used for permissions or roles) for a given tenant or top level if tenant is empty\n * @param authInfo The parsed authentication info from the JWT\n * @param claim name of the claim\n * @param tenant tenant to retrieve the claim for\n * @returns the claim for the given tenant or top level if tenant is empty\n */\nexport function getAuthorizationClaimItems(\n  authInfo: AuthenticationInfo,\n  claim: string,\n  tenant?: string,\n): string[] {\n  const value = tenant\n    ? authInfo.token[authorizedTenantsClaimName]?.[tenant]?.[claim]\n    : authInfo.token[claim];\n  return Array.isArray(value) ? value : [];\n}\n\n/**\n * Check if the user is associated with the given tenant\n * @param authInfo The parsed authentication info from the JWT\n * @param tenant tenant to check if user is associated with\n * @returns true if user is associated with the tenant\n */\nexport function isUserAssociatedWithTenant(authInfo: AuthenticationInfo, tenant: string): boolean {\n  return !!authInfo.token[authorizedTenantsClaimName]?.[tenant];\n}\n","// eslint-disable-next-line import/prefer-default-export\n/** Refresh JWT cookie name */\nexport const refreshTokenCookieName = 'DSR';\n/** Session JWT cookie name */\nexport const sessionTokenCookieName = 'DS';\n/** The key of the tenants claims in the claims map */\nexport const authorizedTenantsClaimName = 'tenants';\n/** The key of the permissions claims in the claims map either under tenant or top level */\nexport const permissionsClaimName = 'permissions';\n/** The key of the roles claims in the claims map either under tenant or top level */\nexport const rolesClaimName = 'roles';\n","/** API paths for the Descope service Management APIs */\nexport default {\n  user: {\n    create: '/v1/mgmt/user/create',\n    createTestUser: '/v1/mgmt/user/create/test',\n    createBatch: '/v1/mgmt/user/create/batch',\n    update: '/v1/mgmt/user/update',\n    patch: '/v1/mgmt/user/patch',\n    delete: '/v1/mgmt/user/delete',\n    deleteAllTestUsers: '/v1/mgmt/user/test/delete/all',\n    load: '/v1/mgmt/user',\n    logout: '/v1/mgmt/user/logout',\n    search: '/v2/mgmt/user/search',\n    searchTestUsers: '/v2/mgmt/user/search/test',\n    getProviderToken: '/v1/mgmt/user/provider/token',\n    updateStatus: '/v1/mgmt/user/update/status',\n    updateLoginId: '/v1/mgmt/user/update/loginid',\n    updateEmail: '/v1/mgmt/user/update/email',\n    updatePhone: '/v1/mgmt/user/update/phone',\n    updateDisplayName: '/v1/mgmt/user/update/name',\n    updatePicture: '/v1/mgmt/user/update/picture',\n    updateCustomAttribute: '/v1/mgmt/user/update/customAttribute',\n    setRole: '/v1/mgmt/user/update/role/set',\n    addRole: '/v2/mgmt/user/update/role/add',\n    removeRole: '/v1/mgmt/user/update/role/remove',\n    setSSOApps: '/v1/mgmt/user/update/ssoapp/set',\n    addSSOApps: '/v1/mgmt/user/update/ssoapp/add',\n    removeSSOApps: '/v1/mgmt/user/update/ssoapp/remove',\n    addTenant: '/v1/mgmt/user/update/tenant/add',\n    removeTenant: '/v1/mgmt/user/update/tenant/remove',\n    setPassword: '/v1/mgmt/user/password/set', // Deprecated\n    setTemporaryPassword: '/v1/mgmt/user/password/set/temporary',\n    setActivePassword: '/v1/mgmt/user/password/set/active',\n    expirePassword: '/v1/mgmt/user/password/expire',\n    removeAllPasskeys: '/v1/mgmt/user/passkeys/delete',\n    generateOTPForTest: '/v1/mgmt/tests/generate/otp',\n    generateMagicLinkForTest: '/v1/mgmt/tests/generate/magiclink',\n    generateEnchantedLinkForTest: '/v1/mgmt/tests/generate/enchantedlink',\n    generateEmbeddedLink: '/v1/mgmt/user/signin/embeddedlink',\n    history: '/v1/mgmt/user/history',\n  },\n  project: {\n    updateName: '/v1/mgmt/project/update/name',\n    updateTags: '/v1/mgmt/project/update/tags',\n    clone: '/v1/mgmt/project/clone',\n    projectsList: '/v1/mgmt/projects/list',\n    exportSnapshot: '/v1/mgmt/project/snapshot/export',\n    importSnapshot: '/v1/mgmt/project/snapshot/import',\n    validateSnapshot: '/v1/mgmt/project/snapshot/validate',\n  },\n  accessKey: {\n    create: '/v1/mgmt/accesskey/create',\n    load: '/v1/mgmt/accesskey',\n    search: '/v1/mgmt/accesskey/search',\n    update: '/v1/mgmt/accesskey/update',\n    deactivate: '/v1/mgmt/accesskey/deactivate',\n    activate: '/v1/mgmt/accesskey/activate',\n    delete: '/v1/mgmt/accesskey/delete',\n  },\n  tenant: {\n    create: '/v1/mgmt/tenant/create',\n    update: '/v1/mgmt/tenant/update',\n    delete: '/v1/mgmt/tenant/delete',\n    load: '/v1/mgmt/tenant',\n    settings: '/v1/mgmt/tenant/settings',\n    loadAll: '/v1/mgmt/tenant/all',\n    searchAll: '/v1/mgmt/tenant/search',\n    generateSSOConfigurationLink: '/v1/mgmt/tenant/adminlinks/sso/generate',\n  },\n  ssoApplication: {\n    oidcCreate: '/v1/mgmt/sso/idp/app/oidc/create',\n    samlCreate: '/v1/mgmt/sso/idp/app/saml/create',\n    oidcUpdate: '/v1/mgmt/sso/idp/app/oidc/update',\n    samlUpdate: '/v1/mgmt/sso/idp/app/saml/update',\n    delete: '/v1/mgmt/sso/idp/app/delete',\n    load: '/v1/mgmt/sso/idp/app/load',\n    loadAll: '/v1/mgmt/sso/idp/apps/load',\n  },\n  sso: {\n    settings: '/v1/mgmt/sso/settings',\n    metadata: '/v1/mgmt/sso/metadata',\n    mapping: '/v1/mgmt/sso/mapping',\n    settingsv2: '/v2/mgmt/sso/settings',\n    oidc: {\n      configure: '/v1/mgmt/sso/oidc',\n    },\n    saml: {\n      configure: '/v1/mgmt/sso/saml',\n      metadata: '/v1/mgmt/sso/saml/metadata',\n    },\n  },\n  jwt: {\n    update: '/v1/mgmt/jwt/update',\n    impersonate: '/v1/mgmt/impersonate',\n  },\n  password: {\n    settings: '/v1/mgmt/password/settings',\n  },\n  permission: {\n    create: '/v1/mgmt/permission/create',\n    update: '/v1/mgmt/permission/update',\n    delete: '/v1/mgmt/permission/delete',\n    loadAll: '/v1/mgmt/permission/all',\n  },\n  role: {\n    create: '/v1/mgmt/role/create',\n    update: '/v1/mgmt/role/update',\n    delete: '/v1/mgmt/role/delete',\n    loadAll: '/v1/mgmt/role/all',\n    search: '/v1/mgmt/role/search',\n  },\n  flow: {\n    list: '/v1/mgmt/flow/list',\n    delete: '/v1/mgmt/flow/delete',\n    export: '/v1/mgmt/flow/export',\n    import: '/v1/mgmt/flow/import',\n  },\n  theme: {\n    export: '/v1/mgmt/theme/export',\n    import: '/v1/mgmt/theme/import',\n  },\n  group: {\n    loadAllGroups: '/v1/mgmt/group/all',\n    loadAllGroupsForMember: '/v1/mgmt/group/member/all',\n    loadAllGroupMembers: '/v1/mgmt/group/members',\n  },\n  audit: {\n    search: '/v1/mgmt/audit/search',\n    createEvent: '/v1/mgmt/audit/event',\n  },\n  authz: {\n    schemaSave: '/v1/mgmt/authz/schema/save',\n    schemaDelete: '/v1/mgmt/authz/schema/delete',\n    schemaLoad: '/v1/mgmt/authz/schema/load',\n    nsSave: '/v1/mgmt/authz/ns/save',\n    nsDelete: '/v1/mgmt/authz/ns/delete',\n    rdSave: '/v1/mgmt/authz/rd/save',\n    rdDelete: '/v1/mgmt/authz/rd/delete',\n    reCreate: '/v1/mgmt/authz/re/create',\n    reDelete: '/v1/mgmt/authz/re/delete',\n    reDeleteResources: '/v1/mgmt/authz/re/deleteresources',\n    hasRelations: '/v1/mgmt/authz/re/has',\n    who: '/v1/mgmt/authz/re/who',\n    resource: '/v1/mgmt/authz/re/resource',\n    targets: '/v1/mgmt/authz/re/targets',\n    targetAll: '/v1/mgmt/authz/re/targetall',\n    getModified: '/v1/mgmt/authz/getmodified',\n  },\n  fga: {\n    schema: '/v1/mgmt/fga/schema',\n    relations: '/v1/mgmt/fga/relations',\n    deleteRelations: '/v1/mgmt/fga/relations/delete',\n    check: '/v1/mgmt/fga/check',\n  },\n};\n","import {\n  SdkResponse,\n  transformResponse,\n  UserHistoryResponse,\n  UserResponse,\n  LoginOptions,\n} from '@descope/core-js-sdk';\nimport {\n  ProviderTokenResponse,\n  AssociatedTenant,\n  GenerateEnchantedLinkForTestResponse,\n  GenerateMagicLinkForTestResponse,\n  GenerateOTPForTestResponse,\n  GenerateEmbeddedLinkResponse,\n  AttributesTypes,\n  UserStatus,\n  User,\n  InviteBatchResponse,\n  TemplateOptions,\n  ProviderTokenOptions,\n} from './types';\nimport { CoreSdk, DeliveryMethodForTestUser } from '../types';\nimport apiPaths from './paths';\n\ntype SearchSort = {\n  field: string;\n  desc?: boolean;\n};\n\ntype SearchRequest = {\n  page?: number;\n  limit?: number;\n  sort?: SearchSort[];\n  text?: string;\n  emails?: string[];\n  phones?: string[];\n  statuses?: UserStatus[];\n  roles?: string[];\n  tenantIds?: string[];\n  customAttributes?: Record<string, AttributesTypes>;\n  withTestUser?: boolean;\n  testUsersOnly?: boolean;\n  ssoAppIds?: string[];\n  loginIds?: string[];\n};\n\ntype SingleUserResponse = {\n  user: UserResponse;\n};\n\ntype MultipleUsersResponse = {\n  users: UserResponse[];\n};\n\nconst withUser = (sdk: CoreSdk, managementKey?: string) => {\n  /* Create User */\n  function create(loginId: string, options?: UserOptions): Promise<SdkResponse<UserResponse>>;\n  function create(\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>>;\n\n  function create(\n    loginId: string,\n    emailOrOptions?: string | UserOptions,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>> {\n    // We support both the old and new parameters forms of create user\n    // 1. The new form - create(loginId, { email, phone, ... }})\n    // 2. The old form - create(loginId, email, phone, ...)\n    const body =\n      typeof emailOrOptions === 'string'\n        ? {\n            loginId,\n            email: emailOrOptions,\n            phone,\n            displayName,\n            givenName,\n            middleName,\n            familyName,\n            roleNames: roles,\n            userTenants,\n            customAttributes,\n            picture,\n            verifiedEmail,\n            verifiedPhone,\n            additionalLoginIds,\n          }\n        : {\n            loginId,\n            ...emailOrOptions,\n            roleNames: emailOrOptions?.roles,\n            roles: undefined,\n          };\n    return transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(apiPaths.user.create, body, { token: managementKey }),\n      (data) => data.user,\n    );\n  }\n  /* Create User End */\n\n  /* Create Test User */\n  function createTestUser(\n    loginId: string,\n    options?: UserOptions,\n  ): Promise<SdkResponse<UserResponse>>;\n  function createTestUser(\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>>;\n\n  function createTestUser(\n    loginId: string,\n    emailOrOptions?: string | UserOptions,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>> {\n    // We support both the old and new parameters forms of create test user\n    // 1. The new form - createTestUser(loginId, { email, phone, ... }})\n    // 2. The old form - createTestUser(loginId, email, phone, ...)\n    const body =\n      typeof emailOrOptions === 'string'\n        ? {\n            loginId,\n            email: emailOrOptions,\n            phone,\n            displayName,\n            givenName,\n            middleName,\n            familyName,\n            roleNames: roles,\n            userTenants,\n            customAttributes,\n            picture,\n            verifiedEmail,\n            verifiedPhone,\n            additionalLoginIds,\n            test: true,\n          }\n        : {\n            loginId,\n            ...emailOrOptions,\n            roleNames: emailOrOptions?.roles,\n            roles: undefined,\n            test: true,\n          };\n    return transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(apiPaths.user.createTestUser, body, { token: managementKey }),\n      (data) => data.user,\n    );\n  }\n  /* Create Test User End */\n\n  /* Invite User */\n  function invite(\n    loginId: string,\n    options?: UserOptions & {\n      inviteUrl?: string;\n      sendMail?: boolean; // send invite via mail, default is according to project settings\n      sendSMS?: boolean; // send invite via text message, default is according to project settings\n      templateOptions?: TemplateOptions;\n      templateId?: string;\n    },\n  ): Promise<SdkResponse<UserResponse>>;\n  function invite(\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    inviteUrl?: string,\n    sendMail?: boolean, // send invite via mail, default is according to project settings\n    sendSMS?: boolean, // send invite via text message, default is according to project settings\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n    templateId?: string,\n  ): Promise<SdkResponse<UserResponse>>;\n\n  function invite(\n    loginId: string,\n    emailOrOptions?: string | UserOptions,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    inviteUrl?: string,\n    sendMail?: boolean, // send invite via mail, default is according to project settings\n    sendSMS?: boolean, // send invite via text message, default is according to project settings\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n    templateId?: string,\n  ): Promise<SdkResponse<UserResponse>> {\n    // We support both the old and new parameters forms of invite user\n    // 1. The new form - invite(loginId, { email, phone, ... }})\n    // 2. The old form - invite(loginId, email, phone, ...)\n    const body =\n      typeof emailOrOptions === 'string'\n        ? {\n            loginId,\n            email: emailOrOptions,\n            phone,\n            displayName,\n            givenName,\n            middleName,\n            familyName,\n            roleNames: roles,\n            userTenants,\n            invite: true,\n            customAttributes,\n            picture,\n            verifiedEmail,\n            verifiedPhone,\n            inviteUrl,\n            sendMail,\n            sendSMS,\n            additionalLoginIds,\n            templateId,\n          }\n        : {\n            loginId,\n            ...emailOrOptions,\n            roleNames: emailOrOptions?.roles,\n            roles: undefined,\n            invite: true,\n          };\n    return transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(apiPaths.user.create, body, { token: managementKey }),\n      (data) => data.user,\n    );\n  }\n  /* Invite User End */\n\n  /* Update User */\n  function update(loginId: string, options?: UserOptions): Promise<SdkResponse<UserResponse>>;\n  function update(\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>>;\n\n  function update(\n    loginId: string,\n    emailOrOptions?: string | UserOptions,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>> {\n    // We support both the old and new parameters forms of update user\n    // 1. The new form - update(loginId, { email, phone, ... }})\n    // 2. The old form - update(loginId, email, phone, ...)\n    const body =\n      typeof emailOrOptions === 'string'\n        ? {\n            loginId,\n            email: emailOrOptions,\n            phone,\n            displayName,\n            givenName,\n            middleName,\n            familyName,\n            roleNames: roles,\n            userTenants,\n            customAttributes,\n            picture,\n            verifiedEmail,\n            verifiedPhone,\n            additionalLoginIds,\n          }\n        : {\n            loginId,\n            ...emailOrOptions,\n            roleNames: emailOrOptions?.roles,\n            roles: undefined,\n          };\n    return transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(apiPaths.user.update, body, { token: managementKey }),\n      (data) => data.user,\n    );\n  }\n  /* Update User End */\n\n  /**\n   * Patches an existing user.\n   * @param loginId The login ID of the user\n   * @param options The fields to update. Only the provided ones will be updated.\n   */\n  function patch(loginId: string, options: PatchUserOptions): Promise<SdkResponse<UserResponse>> {\n    const body = {\n      loginId,\n    } as any;\n\n    if (options.email !== undefined) {\n      body.email = options.email;\n    }\n    if (options.phone !== undefined) {\n      body.phone = options.phone;\n    }\n    if (options.displayName !== undefined) {\n      body.displayName = options.displayName;\n    }\n    if (options.givenName !== undefined) {\n      body.givenName = options.givenName;\n    }\n    if (options.middleName !== undefined) {\n      body.middleName = options.middleName;\n    }\n    if (options.familyName !== undefined) {\n      body.familyName = options.familyName;\n    }\n    if (options.roles !== undefined) {\n      body.roleNames = options.roles;\n    }\n    if (options.userTenants !== undefined) {\n      body.userTenants = options.userTenants;\n    }\n    if (options.customAttributes !== undefined) {\n      body.customAttributes = options.customAttributes;\n    }\n    if (options.picture !== undefined) {\n      body.picture = options.picture;\n    }\n    if (options.verifiedEmail !== undefined) {\n      body.verifiedEmail = options.verifiedEmail;\n    }\n    if (options.verifiedPhone !== undefined) {\n      body.verifiedPhone = options.verifiedPhone;\n    }\n    if (options.ssoAppIds !== undefined) {\n      body.ssoAppIds = options.ssoAppIds;\n    }\n\n    return transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.patch(apiPaths.user.patch, body, { token: managementKey }),\n      (data) => data.user,\n    );\n  }\n\n  return {\n    create,\n    /**\n     * Create a new test user.\n     * The loginID is required and will determine what the user will use to sign in.\n     * Make sure the login id is unique for test. All other fields are optional.\n     *\n     * You can later generate OTP, Magic link and enchanted link to use in the test without the need\n     * of 3rd party messaging services.\n     * Those users are not counted as part of the monthly active users\n     * @returns The UserResponse if found, throws otherwise.\n     */\n    createTestUser,\n    invite,\n    inviteBatch: (\n      users: User[],\n      inviteUrl?: string,\n      sendMail?: boolean, // send invite via mail, default is according to project settings\n      sendSMS?: boolean, // send invite via text message, default is according to project settings\n      templateOptions?: TemplateOptions,\n      templateId?: string,\n    ): Promise<SdkResponse<InviteBatchResponse>> =>\n      transformResponse<InviteBatchResponse, InviteBatchResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.createBatch,\n          {\n            users: users.map((u) => {\n              const res = {\n                ...u,\n                roleNames: u.roles,\n              };\n              delete res.roles;\n              return res;\n            }),\n            invite: true,\n            inviteUrl,\n            sendMail,\n            sendSMS,\n            templateOptions,\n            templateId,\n          },\n          { token: managementKey },\n        ),\n        (data) => data,\n      ),\n    update,\n    patch,\n    /**\n     * Delete an existing user.\n     * @param loginId The login ID of the user\n     */\n    delete: (loginId: string): Promise<SdkResponse<never>> =>\n      transformResponse(\n        sdk.httpClient.post(apiPaths.user.delete, { loginId }, { token: managementKey }),\n      ),\n    /**\n     * Delete an existing user by User ID.\n     * @param userId The user ID can be found in the Subject (`sub`) claim\n     * in the user's JWT.\n     */\n    deleteByUserId: (userId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse(\n        sdk.httpClient.post(apiPaths.user.delete, { userId }, { token: managementKey }),\n      ),\n    /**\n     * Delete all test users in the project.\n     */\n    deleteAllTestUsers: (): Promise<SdkResponse<never>> =>\n      transformResponse(\n        sdk.httpClient.delete(apiPaths.user.deleteAllTestUsers, { token: managementKey }),\n      ),\n    load: (loginId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.get(apiPaths.user.load, {\n          queryParams: { loginId },\n          token: managementKey,\n        }),\n        (data) => data.user,\n      ),\n    /**\n     * Load an existing user by user ID. The ID can be found\n     * on the user's JWT.\n     * @param userId load a user by this user ID field\n     * @returns The UserResponse if found, throws otherwise.\n     */\n    loadByUserId: (userId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.get(apiPaths.user.load, {\n          queryParams: { userId },\n          token: managementKey,\n        }),\n        (data) => data.user,\n      ),\n    /**\n     * Logout a user from all devices by the login ID\n     * @param loginId logout user by login ID\n     * @returns The UserResponse if found, throws otherwise.\n     */\n    logoutUser: (loginId: string): Promise<SdkResponse<never>> =>\n      transformResponse(\n        sdk.httpClient.post(apiPaths.user.logout, { loginId }, { token: managementKey }),\n      ),\n    /**\n     * Logout a user from all devices by user ID. The ID can be found\n     * on the user's JWT.\n     * @param userId Logout a user from all devices by this user ID field\n     * @returns The UserResponse if found, throws otherwise.\n     */\n    logoutUserByUserId: (userId: string): Promise<SdkResponse<never>> =>\n      transformResponse(\n        sdk.httpClient.post(apiPaths.user.logout, { userId }, { token: managementKey }),\n      ),\n    /**\n     * Search all users. Results can be filtered according to tenants and/or\n     * roles, and also paginated used the limit and page parameters.\n     * @deprecated Use search instead\n     * @param tenantIds optional list of tenant IDs to filter by\n     * @param roles optional list of roles to filter by\n     * @param limit optionally limit the response, leave out for default limit\n     * @param page optionally paginate over the response\n     * @param testUsersOnly optionally filter only test users\n     * @param withTestUser optionally include test users in search\n     * @returns An array of UserResponse found by the query\n     */\n    searchAll: (\n      tenantIds?: string[],\n      roles?: string[],\n      limit?: number,\n      page?: number,\n      testUsersOnly?: boolean,\n      withTestUser?: boolean,\n      customAttributes?: Record<string, AttributesTypes>,\n      statuses?: UserStatus[],\n      emails?: string[],\n      phones?: string[],\n    ): Promise<SdkResponse<UserResponse[]>> =>\n      transformResponse<MultipleUsersResponse, UserResponse[]>(\n        sdk.httpClient.post(\n          apiPaths.user.search,\n          {\n            tenantIds,\n            roleNames: roles,\n            limit,\n            page,\n            testUsersOnly,\n            withTestUser,\n            customAttributes,\n            statuses,\n            emails,\n            phones,\n          },\n          { token: managementKey },\n        ),\n        (data) => data.users,\n      ),\n    searchTestUsers: (searchReq: SearchRequest): Promise<SdkResponse<UserResponse[]>> =>\n      transformResponse<MultipleUsersResponse, UserResponse[]>(\n        sdk.httpClient.post(\n          apiPaths.user.searchTestUsers,\n          {\n            ...searchReq,\n            withTestUser: true,\n            testUsersOnly: true,\n            roleNames: searchReq.roles,\n            roles: undefined,\n          },\n          { token: managementKey },\n        ),\n        (data) => data.users,\n      ),\n    search: (searchReq: SearchRequest): Promise<SdkResponse<UserResponse[]>> =>\n      transformResponse<MultipleUsersResponse, UserResponse[]>(\n        sdk.httpClient.post(\n          apiPaths.user.search,\n          {\n            ...searchReq,\n            roleNames: searchReq.roles,\n            roles: undefined,\n          },\n          { token: managementKey },\n        ),\n        (data) => data.users,\n      ),\n    /**\n     * Get the provider token for the given login ID.\n     * Only users that logged-in using social providers will have token.\n     * Note: The 'Manage tokens from provider' setting must be enabled.\n     * @param loginId the login ID of the user\n     * @param provider the provider name (google, facebook, etc.).\n     * @param providerTokenOptions optional, includes options for getting the provider token:\n     *    withRefreshToken - include the refresh token in the response\n     *    forceRefresh - force to refresh the token\n     * @returns The ProviderTokenResponse of the given user and provider\n     */\n    getProviderToken: (\n      loginId: string,\n      provider: string,\n      providerTokenOptions?: ProviderTokenOptions,\n    ): Promise<SdkResponse<ProviderTokenResponse>> =>\n      transformResponse<ProviderTokenResponse>(\n        sdk.httpClient.get(apiPaths.user.getProviderToken, {\n          queryParams: {\n            loginId,\n            provider,\n            withRefreshToken: providerTokenOptions?.withRefreshToken ? 'true' : 'false',\n            forceRefresh: providerTokenOptions?.forceRefresh ? 'true' : 'false',\n          },\n          token: managementKey,\n        }),\n        (data) => data,\n      ),\n    activate: (loginId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.updateStatus,\n          { loginId, status: 'enabled' },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    deactivate: (loginId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.updateStatus,\n          { loginId, status: 'disabled' },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    updateLoginId: (loginId: string, newLoginId?: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.updateLoginId,\n          { loginId, newLoginId },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    updateEmail: (\n      loginId: string,\n      email: string,\n      isVerified: boolean,\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.updateEmail,\n          { loginId, email, verified: isVerified },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    updatePhone: (\n      loginId: string,\n      phone: string,\n      isVerified: boolean,\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.updatePhone,\n          { loginId, phone, verified: isVerified },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    updateDisplayName: (\n      loginId: string,\n      displayName?: string,\n      givenName?: string,\n      middleName?: string,\n      familyName?: string,\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.updateDisplayName,\n          { loginId, displayName, givenName, middleName, familyName },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    updatePicture: (loginId: string, picture: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.updatePicture,\n          { loginId, picture },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    updateCustomAttribute: (\n      loginId: string,\n      attributeKey: string,\n      attributeValue: AttributesTypes,\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.updateCustomAttribute,\n          { loginId, attributeKey, attributeValue },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    setRoles: (loginId: string, roles: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.setRole,\n          { loginId, roleNames: roles },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    addRoles: (loginId: string, roles: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.addRole,\n          { loginId, roleNames: roles },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    removeRoles: (loginId: string, roles: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.removeRole,\n          { loginId, roleNames: roles },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    addTenant: (loginId: string, tenantId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.addTenant,\n          { loginId, tenantId },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    removeTenant: (loginId: string, tenantId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.removeTenant,\n          { loginId, tenantId },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    setTenantRoles: (\n      loginId: string,\n      tenantId: string,\n      roles: string[],\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.setRole,\n          { loginId, tenantId, roleNames: roles },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    addTenantRoles: (\n      loginId: string,\n      tenantId: string,\n      roles: string[],\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.addRole,\n          { loginId, tenantId, roleNames: roles },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    removeTenantRoles: (\n      loginId: string,\n      tenantId: string,\n      roles: string[],\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.removeRole,\n          { loginId, tenantId, roleNames: roles },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    addSSOapps: (loginId: string, ssoAppIds: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.addSSOApps,\n          { loginId, ssoAppIds },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    setSSOapps: (loginId: string, ssoAppIds: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.setSSOApps,\n          { loginId, ssoAppIds },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n    removeSSOapps: (loginId: string, ssoAppIds: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.removeSSOApps,\n          { loginId, ssoAppIds },\n          { token: managementKey },\n        ),\n        (data) => data.user,\n      ),\n\n    /**\n     * Generate OTP for the given login ID of a test user.\n     * Choose the selected delivery method for verification.\n     * Returns the code for the login (exactly as it sent via Email, SMS, Voice call or WhatsApp)\n     * This is useful when running tests and don't want to use 3rd party messaging services\n     *\n     * @param deliveryMethod optional DeliveryMethod\n     * @param loginId login ID of a test user\n     * @param loginOptions optional LoginOptions - can be provided to set custom claims to the generated jwt.\n     * @returns GenerateOTPForTestResponse which includes the loginId and the OTP code\n     */\n    generateOTPForTestUser: (\n      deliveryMethod: DeliveryMethodForTestUser,\n      loginId: string,\n      loginOptions?: LoginOptions,\n    ): Promise<SdkResponse<GenerateOTPForTestResponse>> =>\n      transformResponse<GenerateOTPForTestResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.generateOTPForTest,\n          { deliveryMethod, loginId, loginOptions },\n          { token: managementKey },\n        ),\n        (data) => data,\n      ),\n\n    /**\n     * Generate Magic Link for the given login ID of a test user.\n     * Choose the selected delivery method for verification.\n     * It returns the link for the login (exactly as it sent via Email)\n     * This is useful when running tests and don't want to use 3rd party messaging services\n     *\n     * @param deliveryMethod optional DeliveryMethod\n     * @param loginId login ID of a test user\n     * @param uri optional redirect uri which will be used instead of any global configuration.\n     * @param loginOptions optional LoginOptions - can be provided to set custom claims to the generated jwt.\n     * @returns GenerateMagicLinkForTestResponse which includes the loginId and the magic link\n     */\n    generateMagicLinkForTestUser: (\n      deliveryMethod: DeliveryMethodForTestUser,\n      loginId: string,\n      uri: string,\n      loginOptions?: LoginOptions,\n    ): Promise<SdkResponse<GenerateMagicLinkForTestResponse>> =>\n      transformResponse<GenerateMagicLinkForTestResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.generateMagicLinkForTest,\n          { deliveryMethod, loginId, URI: uri, loginOptions },\n          { token: managementKey },\n        ),\n        (data) => data,\n      ),\n\n    /**\n     * Generate Enchanted Link for the given login ID of a test user.\n     * It returns the link for the login (exactly as it sent via Email)\n     * and pendingRef which is used to poll for a valid session\n     * This is useful when running tests and don't want to use 3rd party messaging services\n     *\n     * @param loginId login ID of a test user\n     * @param uri optional redirect uri which will be used instead of any global configuration.\n     * @param loginOptions optional LoginOptions - can be provided to set custom claims to the generated jwt.\n     * @returns GenerateEnchantedLinkForTestResponse which includes the loginId, the enchanted link and the pendingRef\n     */\n    generateEnchantedLinkForTestUser: (\n      loginId: string,\n      uri: string,\n      loginOptions?: LoginOptions,\n    ): Promise<SdkResponse<GenerateEnchantedLinkForTestResponse>> =>\n      transformResponse<GenerateEnchantedLinkForTestResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.generateEnchantedLinkForTest,\n          { loginId, URI: uri, loginOptions },\n          { token: managementKey },\n        ),\n        (data) => data,\n      ),\n\n    generateEmbeddedLink: (\n      loginId: string,\n      customClaims?: Record<string, any>,\n    ): Promise<SdkResponse<GenerateEmbeddedLinkResponse>> =>\n      transformResponse<GenerateEmbeddedLinkResponse>(\n        sdk.httpClient.post(\n          apiPaths.user.generateEmbeddedLink,\n          { loginId, customClaims },\n          { token: managementKey },\n        ),\n        (data) => data,\n      ),\n\n    /**\n     * Set temporary password for the given login ID of user.\n     * Note: The password will automatically be set as expired.\n     * The user will not be able to log-in with this password, and will be required to replace it on next login.\n     * See also: expirePassword\n     * @param loginId The login ID of the user\n     * @param password The password to set for the user\n     */\n    setTemporaryPassword: (loginId: string, password: string): Promise<SdkResponse<never>> =>\n      transformResponse<never>(\n        sdk.httpClient.post(\n          apiPaths.user.setTemporaryPassword,\n          { loginId, password },\n          { token: managementKey },\n        ),\n        (data) => data,\n      ),\n\n    /**\n     * Set password for the given login ID of user.\n     * @param loginId The login ID of the user\n     * @param password The password to set for the user\n     */\n    setActivePassword: (loginId: string, password: string): Promise<SdkResponse<never>> =>\n      transformResponse<never>(\n        sdk.httpClient.post(\n          apiPaths.user.setActivePassword,\n          { loginId, password },\n          { token: managementKey },\n        ),\n        (data) => data,\n      ),\n\n    /** Deprecated (user setTemporaryPassword instead)\n     * Set password for the given login ID of user.\n     * Note: The password will automatically be set as expired.\n     * The user will not be able to log-in with this password, and will be required to replace it on next login.\n     * See also: expirePassword\n     * @param loginId The login ID of the user\n     * @param password The password to set for the user\n     */\n    setPassword: (loginId: string, password: string): Promise<SdkResponse<never>> =>\n      transformResponse<never>(\n        sdk.httpClient.post(\n          apiPaths.user.setPassword,\n          { loginId, password },\n          { token: managementKey },\n        ),\n        (data) => data,\n      ),\n\n    /**\n     * Expire password for the given login ID.\n     * Note: user sign-in with an expired password, the user will get an error with code.\n     * Use the `ResetPassword` or `ReplacePassword` methods to reset/replace the password.\n     * @param loginId The login ID of the user\n     */\n    expirePassword: (loginId: string): Promise<SdkResponse<never>> =>\n      transformResponse<never>(\n        sdk.httpClient.post(apiPaths.user.expirePassword, { loginId }, { token: managementKey }),\n        (data) => data,\n      ),\n\n    /**\n     * Removes all registered passkeys (WebAuthn devices) for the user with the given login ID.\n     * Note: The user might not be able to login anymore if they have no other authentication\n     * methods or a verified email/phone.\n     * @param loginId The login ID of the user\n     */\n    removeAllPasskeys: (loginId: string): Promise<SdkResponse<never>> =>\n      transformResponse<never>(\n        sdk.httpClient.post(apiPaths.user.removeAllPasskeys, { loginId }, { token: managementKey }),\n        (data) => data,\n      ),\n\n    /**\n     * Retrieve users' authentication history, by the given user's ids.\n     * @param userIds The user IDs\n     */\n    history: (userIds: string[]): Promise<SdkResponse<UserHistoryResponse[]>> =>\n      transformResponse<UserHistoryResponse[]>(\n        sdk.httpClient.post(apiPaths.user.history, userIds, { token: managementKey }),\n        (data) => data,\n      ),\n  };\n};\n\nexport interface UserOptions {\n  email?: string;\n  phone?: string;\n  displayName?: string;\n  roles?: string[];\n  userTenants?: AssociatedTenant[];\n  customAttributes?: Record<string, AttributesTypes>;\n  picture?: string;\n  verifiedEmail?: boolean;\n  verifiedPhone?: boolean;\n  givenName?: string;\n  middleName?: string;\n  familyName?: string;\n  additionalLoginIds?: string[];\n  ssoAppIds?: string[];\n}\n\nexport interface PatchUserOptions {\n  email?: string;\n  phone?: string;\n  displayName?: string;\n  roles?: string[];\n  userTenants?: AssociatedTenant[];\n  customAttributes?: Record<string, AttributesTypes>;\n  picture?: string;\n  verifiedEmail?: boolean;\n  verifiedPhone?: boolean;\n  givenName?: string;\n  middleName?: string;\n  familyName?: string;\n  ssoAppIds?: string[];\n}\n\nexport default withUser;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport {\n  CloneProjectResponse,\n  ExportSnapshotResponse,\n  ImportSnapshotRequest,\n  Project,\n  ProjectEnvironment,\n  ValidateSnapshotRequest,\n  ValidateSnapshotResponse,\n} from './types';\n\ntype ListProjectsResponse = {\n  projects: Project[];\n};\n\nconst withProject = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * Update the current project name.\n   * @param name The new name of the project\n   */\n  updateName: (name: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.project.updateName,\n        {\n          name,\n        },\n        { token: managementKey },\n      ),\n    ),\n\n  /**\n   * Update the current project tags.\n   * @param tags The wanted tags\n   */\n  updateTags: (tags: string[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.project.updateTags,\n        {\n          tags,\n        },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Clone the current project, including its settings and configurations.\n   *  - This action is supported only with a pro license or above.\n   *  - Users, tenants and access keys are not cloned.\n   * @param name The name of the new project\n   * @param environment Determine if the project is in production or not.\n   * @param tags array of free text tags\n   * @returns The new project details (name, id, environment and tags)\n   */\n  clone: (\n    name: string,\n    environment?: ProjectEnvironment,\n    tags?: string[],\n  ): Promise<SdkResponse<CloneProjectResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.project.clone,\n        {\n          name,\n          environment,\n          tags,\n        },\n        { token: managementKey },\n      ),\n    ),\n\n  /**\n   * list of all the projects in the company\n   * @returns List of projects details (name, id, environment and tags)\n   */\n  listProjects: async (): Promise<SdkResponse<Project[]>> =>\n    transformResponse<ListProjectsResponse, Project[]>(\n      sdk.httpClient.post(\n        apiPaths.project.projectsList,\n        {},\n        {\n          token: managementKey,\n        },\n      ),\n      (data) =>\n        data.projects.map(({ id, name, environment, tags }) => ({\n          id,\n          name,\n          environment,\n          tags,\n        })),\n    ),\n\n  /**\n   *\n   * Exports a snapshot of all the settings and configurations for a project and returns\n   * the raw JSON files as a mape. Note that users, tenants and access keys are not exported.\n   *\n   * This call is supported only with a pro license or above.\n   *\n   * Note: The values for secrets such as tokens and keys are left blank in the snapshot.\n   * When a snapshot is imported into a project, the secrets for entities that already\n   * exist such as connectors or OAuth providers are preserved if the matching values\n   * in the snapshot are left blank. See below for more details.\n   *\n   * This API is meant to be used via the 'descope' CLI tool that can be\n   * found at https://github.com/descope/descopecli\n   *\n   * @returns An `ExportSnapshotResponse` object containing the exported JSON files.\n   */\n  exportSnapshot: (): Promise<SdkResponse<ExportSnapshotResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.project.exportSnapshot, {}, { token: managementKey }),\n    ),\n\n  /**\n   * Imports a snapshot of all settings and configurations into a project, overriding any\n   * current configuration.\n   *\n   * This call is supported only with a pro license or above.\n   *\n   * The request is expected to be an `ImportSnapshotRequest` object with a raw JSON map of\n   * files in the same format as the one returned in the `files` field of an `exportSnapshot`\n   * response.\n   *\n   * Note: The values for secrets such as tokens and keys are left blank in exported\n   * snapshots. When a snapshot is imported into a project, the secrets for entities that\n   * already exist such as connectors or OAuth providers are preserved if the matching values\n   * in the snapshot are left blank. However, new entities that need to be created during\n   * the import operation must any required secrets provided in the request, otherwise the\n   * import operation will fail. The ValidateImport method can be used to get a human and\n   * machine readable JSON of missing secrets that be passed to the ImportSnapshot call.\n   *\n   * This API is meant to be used via the 'descope' CLI tool that can be\n   * found at https://github.com/descope/descopecli\n   */\n  importSnapshot: (request: ImportSnapshotRequest): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.project.importSnapshot, request, { token: managementKey }),\n    ),\n\n  /**\n   * Validates a snapshot by performing an import dry run and reporting any validation\n   * failures or missing data. This should be called right before `importSnapshot` to\n   * minimize the risk of the import failing.\n   *\n   * This call is supported only with a pro license or above.\n   *\n   * The response will have `ok: true` if the validation passes. Otherwise, a list of\n   * failures will be provided in the `failures` field, and any missing secrets will\n   * be listed along with details about which entity requires them.\n   *\n   * Validation can be retried by setting the required cleartext secret values in the\n   * `value` field of each missing secret and setting this object as the `inputSecrets`\n   * field of the validate request. The same `inputSecrets` object should then be\n   * provided to the `importSnapshot` call afterwards so it doesn't fail as well.\n   *\n   * This API is meant to be used via the 'descope' CLI tool that can be\n   * found at https://github.com/descope/descopecli\n   */\n  validateSnapshot: (\n    request: ValidateSnapshotRequest,\n  ): Promise<SdkResponse<ValidateSnapshotResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.project.validateSnapshot, request, { token: managementKey }),\n    ),\n\n  /**\n   * @deprecated Use exportSnapshot instead\n   */\n  export: (): Promise<SdkResponse<Record<string, any>>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.project.exportSnapshot, {}, { token: managementKey }),\n      (data) => data.files,\n    ),\n\n  /**\n   * @deprecated Use importSnapshot instead\n   */\n  import: (files: Record<string, any>): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.project.importSnapshot,\n        {\n          files,\n        },\n        { token: managementKey },\n      ),\n    ),\n});\n\nexport default withProject;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport {\n  CreateTenantResponse,\n  Tenant,\n  AttributesTypes,\n  TenantSettings,\n  GenerateSSOConfigurationLinkResponse,\n} from './types';\n\ntype MultipleTenantResponse = {\n  tenants: Tenant[];\n};\n\nconst withTenant = (sdk: CoreSdk, managementKey?: string) => ({\n  create: (\n    name: string,\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n  ): Promise<SdkResponse<CreateTenantResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.tenant.create,\n        { name, selfProvisioningDomains, customAttributes },\n        { token: managementKey },\n      ),\n    ),\n  createWithId: (\n    id: string,\n    name: string,\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.tenant.create,\n        { id, name, selfProvisioningDomains, customAttributes },\n        { token: managementKey },\n      ),\n    ),\n  update: (\n    id: string,\n    name: string,\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.tenant.update,\n        { id, name, selfProvisioningDomains, customAttributes },\n        { token: managementKey },\n      ),\n    ),\n  delete: (id: string, cascade?: boolean): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.tenant.delete, { id, cascade }, { token: managementKey }),\n    ),\n  load: (id: string): Promise<SdkResponse<Tenant>> =>\n    transformResponse<Tenant, Tenant>(\n      sdk.httpClient.get(apiPaths.tenant.load, {\n        queryParams: { id },\n        token: managementKey,\n      }),\n      (data) => data,\n    ),\n  loadAll: (): Promise<SdkResponse<Tenant[]>> =>\n    transformResponse<MultipleTenantResponse, Tenant[]>(\n      sdk.httpClient.get(apiPaths.tenant.loadAll, {\n        token: managementKey,\n      }),\n      (data) => data.tenants,\n    ),\n  searchAll: (\n    ids?: string[],\n    names?: string[],\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n  ): Promise<SdkResponse<Tenant[]>> =>\n    transformResponse<MultipleTenantResponse, Tenant[]>(\n      sdk.httpClient.post(\n        apiPaths.tenant.searchAll,\n        {\n          tenantIds: ids,\n          tenantNames: names,\n          tenantSelfProvisioningDomains: selfProvisioningDomains,\n          customAttributes,\n        },\n        { token: managementKey },\n      ),\n      (data) => data.tenants,\n    ),\n  getSettings: (tenantId: string): Promise<SdkResponse<TenantSettings>> =>\n    transformResponse<TenantSettings, TenantSettings>(\n      sdk.httpClient.get(apiPaths.tenant.settings, {\n        queryParams: { id: tenantId },\n        token: managementKey,\n      }),\n      (data) => data,\n    ),\n  configureSettings: (tenantId: string, settings: TenantSettings): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.tenant.settings,\n        { ...settings, tenantId },\n        {\n          token: managementKey,\n        },\n      ),\n    ),\n  generateSSOConfigurationLink: (\n    tenantId: string,\n    expireDuration: number,\n  ): Promise<SdkResponse<GenerateSSOConfigurationLinkResponse>> =>\n    transformResponse<GenerateSSOConfigurationLinkResponse, GenerateSSOConfigurationLinkResponse>(\n      sdk.httpClient.post(\n        apiPaths.tenant.generateSSOConfigurationLink,\n        { tenantId, expireTime: expireDuration },\n        {\n          token: managementKey,\n        },\n      ),\n      (data) => data,\n    ),\n});\n\nexport default withTenant;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { UpdateJWTResponse } from './types';\n\nconst withJWT = (sdk: CoreSdk, managementKey?: string) => ({\n  update: (\n    jwt: string,\n    customClaims?: Record<string, any>,\n  ): Promise<SdkResponse<UpdateJWTResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.jwt.update, { jwt, customClaims }, { token: managementKey }),\n    ),\n  impersonate: (\n    impersonatorId: string,\n    loginId: string,\n    validateConsent: boolean,\n    customClaims?: Record<string, any>,\n    selectedTenant?: string,\n  ): Promise<SdkResponse<UpdateJWTResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.jwt.impersonate,\n        { impersonatorId, loginId, validateConsent, customClaims, selectedTenant },\n        { token: managementKey },\n      ),\n    ),\n});\n\nexport default withJWT;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { Permission } from './types';\n\ntype MultiplePermissionResponse = {\n  permissions: Permission[];\n};\n\nconst withPermission = (sdk: CoreSdk, managementKey?: string) => ({\n  create: (name: string, description?: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.permission.create,\n        { name, description },\n        { token: managementKey },\n      ),\n    ),\n  update: (name: string, newName: string, description?: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.permission.update,\n        { name, newName, description },\n        { token: managementKey },\n      ),\n    ),\n  delete: (name: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.permission.delete, { name }, { token: managementKey }),\n    ),\n  loadAll: (): Promise<SdkResponse<Permission[]>> =>\n    transformResponse<MultiplePermissionResponse, Permission[]>(\n      sdk.httpClient.get(apiPaths.permission.loadAll, {\n        token: managementKey,\n      }),\n      (data) => data.permissions,\n    ),\n});\n\nexport default withPermission;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { Role, RoleSearchOptions } from './types';\n\ntype MultipleRoleResponse = {\n  roles: Role[];\n};\n\nconst withRole = (sdk: CoreSdk, managementKey?: string) => ({\n  create: (\n    name: string,\n    description?: string,\n    permissionNames?: string[],\n    tenantId?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.role.create,\n        { name, description, permissionNames, tenantId },\n        { token: managementKey },\n      ),\n    ),\n  update: (\n    name: string,\n    newName: string,\n    description?: string,\n    permissionNames?: string[],\n    tenantId?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.role.update,\n        { name, newName, description, permissionNames, tenantId },\n        { token: managementKey },\n      ),\n    ),\n  delete: (name: string, tenantId?: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.role.delete, { name, tenantId }, { token: managementKey }),\n    ),\n  loadAll: (): Promise<SdkResponse<Role[]>> =>\n    transformResponse<MultipleRoleResponse, Role[]>(\n      sdk.httpClient.get(apiPaths.role.loadAll, {\n        token: managementKey,\n      }),\n      (data) => data.roles,\n    ),\n  search: (options: RoleSearchOptions): Promise<SdkResponse<Role[]>> =>\n    transformResponse<MultipleRoleResponse, Role[]>(\n      sdk.httpClient.post(apiPaths.role.search, options, {\n        token: managementKey,\n      }),\n      (data) => data.roles,\n    ),\n});\n\nexport default withRole;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { Group } from './types';\n\nconst withGroup = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * Load all groups for a specific tenant id.\n   * @param tenantId Tenant ID to load groups from.\n   * @returns Group[] list of groups\n   */\n  loadAllGroups: (tenantId: string): Promise<SdkResponse<Group[]>> =>\n    transformResponse<Group[]>(\n      sdk.httpClient.post(apiPaths.group.loadAllGroups, { tenantId }, { token: managementKey }),\n    ),\n\n  /**\n   * Load all groups for the provided user IDs or login IDs.\n   * @param tenantId Tenant ID to load groups from.\n   * @param userIds Optional List of user IDs, with the format of \"U2J5ES9S8TkvCgOvcrkpzUgVTEBM\" (example), which can be found on the user's JWT.\n   * @param loginIds Optional List of login IDs, how the user identifies when logging in.\n   * @returns Group[] list of groups\n   */\n  loadAllGroupsForMember: (\n    tenantId: string,\n    userIds: string[],\n    loginIds: string[],\n  ): Promise<SdkResponse<Group[]>> =>\n    transformResponse<Group[]>(\n      sdk.httpClient.post(\n        apiPaths.group.loadAllGroupsForMember,\n        { tenantId, loginIds, userIds },\n        { token: managementKey },\n      ),\n    ),\n\n  /**\n   * Load all members of the provided group id.\n   * @param tenantId Tenant ID to load groups from.\n   * @param groupId Group ID to load members for.\n   * @returns Group[] list of groups\n   */\n  loadAllGroupMembers: (tenantId: string, groupId: string): Promise<SdkResponse<Group[]>> =>\n    transformResponse<Group[]>(\n      sdk.httpClient.post(\n        apiPaths.group.loadAllGroupMembers,\n        { tenantId, groupId },\n        { token: managementKey },\n      ),\n    ),\n});\n\nexport default withGroup;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport {\n  RoleMappings,\n  AttributeMapping,\n  SSOSettingsResponse,\n  SSOOIDCSettings,\n  SSOSAMLSettings,\n  SSOSAMLByMetadataSettings,\n  SSOSettings,\n} from './types';\n\nconst withSSOSettings = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * @deprecated  Use loadSettings instead\n   */\n  getSettings: (tenantId: string): Promise<SdkResponse<SSOSettingsResponse>> =>\n    transformResponse<SSOSettingsResponse>(\n      sdk.httpClient.get(apiPaths.sso.settings, {\n        queryParams: { tenantId },\n        token: managementKey,\n      }),\n      (data) => data,\n    ),\n  deleteSettings: (tenantId: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.delete(apiPaths.sso.settings, {\n        queryParams: { tenantId },\n        token: managementKey,\n      }),\n    ),\n  /**\n   * @deprecated  Use configureSAMLSettings instead\n   */\n  configureSettings: (\n    tenantId: string,\n    idpURL: string,\n    idpCert: string,\n    entityId: string,\n    redirectURL: string,\n    domains: string[],\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.sso.settings,\n        { tenantId, idpURL, entityId, idpCert, redirectURL, domains },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * @deprecated  Use configureSAMLByMetadata instead\n   */\n  configureMetadata: (\n    tenantId: string,\n    idpMetadataURL: string,\n    redirectURL: string,\n    domains: string[],\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.sso.metadata,\n        { tenantId, idpMetadataURL, redirectURL, domains },\n        { token: managementKey },\n      ),\n    ),\n  configureMapping: (\n    tenantId: string,\n    roleMappings?: RoleMappings,\n    attributeMapping?: AttributeMapping,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.sso.mapping,\n        { tenantId, roleMappings, attributeMapping },\n        { token: managementKey },\n      ),\n    ),\n  configureOIDCSettings: (\n    tenantId: string,\n    settings: SSOOIDCSettings,\n    domains?: string[],\n  ): Promise<SdkResponse<never>> => {\n    const readySettings = { ...settings, userAttrMapping: settings.attributeMapping };\n    delete readySettings.attributeMapping;\n    return transformResponse(\n      sdk.httpClient.post(\n        apiPaths.sso.oidc.configure,\n        {\n          tenantId,\n          settings: readySettings,\n          domains,\n        },\n        { token: managementKey },\n      ),\n    );\n  },\n  configureSAMLSettings: (\n    tenantId: string,\n    settings: SSOSAMLSettings,\n    redirectUrl?: string,\n    domains?: string[],\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.sso.saml.configure,\n        { tenantId, settings, redirectUrl, domains },\n        { token: managementKey },\n      ),\n    ),\n  configureSAMLByMetadata: (\n    tenantId: string,\n    settings: SSOSAMLByMetadataSettings,\n    redirectUrl?: string,\n    domains?: string[],\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.sso.saml.metadata,\n        { tenantId, settings, redirectUrl, domains },\n        { token: managementKey },\n      ),\n    ),\n  loadSettings: (tenantId: string): Promise<SdkResponse<SSOSettings>> =>\n    transformResponse<SSOSettings>(\n      sdk.httpClient.get(apiPaths.sso.settingsv2, {\n        queryParams: { tenantId },\n        token: managementKey,\n      }),\n      (data) => {\n        const readySettings = data as any;\n        if (readySettings.oidc) {\n          readySettings.oidc = {\n            ...readySettings.oidc,\n            attributeMapping: readySettings.oidc.userAttrMapping,\n          };\n          delete readySettings.oidc.userAttrMapping;\n        }\n        if (readySettings.saml?.groupsMapping) {\n          readySettings.saml.groupsMapping = readySettings.saml?.groupsMapping.map((gm: any) => {\n            const rm = gm;\n            rm.roleName = rm.role.name;\n            delete rm.role;\n            return rm;\n          });\n        }\n        return readySettings;\n      },\n    ),\n});\n\nexport default withSSOSettings;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { AccessKey, AssociatedTenant, CreatedAccessKeyResponse } from './types';\n\ntype SingleKeyResponse = {\n  key: AccessKey;\n};\n\ntype MultipleKeysResponse = {\n  keys: AccessKey[];\n};\n\nconst withAccessKey = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * Create a new access key for a project.\n   * @param name Access key name\n   * @param expireTime When the access key expires. Keep at 0 to make it indefinite.\n   * @param roles Optional roles in the project. Does not apply for multi-tenants\n   * @param keyTenants Optional associated tenants for this key and its roles for each.\n   * @param userId Optional bind this access key to a specific user.\n   * @param customClaims Optional map of claims and their values that will be present in the JWT.\n   * @param description Optional free text description\n   * @param permittedIps Optional list of IP addresses or CIDR ranges that are allowed to use this access key.\n   * @returns A newly created key and its cleartext. Make sure to save the cleartext securely.\n   */\n  create: (\n    name: string,\n    expireTime: number,\n    roles?: string[],\n    keyTenants?: AssociatedTenant[],\n    userId?: string,\n    customClaims?: Record<string, any>,\n    description?: string,\n    permittedIps?: string[],\n  ): Promise<SdkResponse<CreatedAccessKeyResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.accessKey.create,\n        {\n          name,\n          expireTime,\n          roleNames: roles,\n          keyTenants,\n          userId,\n          customClaims,\n          description,\n          permittedIps,\n        },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Load an access key.\n   * @param id Access key ID to load\n   * @returns The loaded access key.\n   */\n  load: (id: string): Promise<SdkResponse<AccessKey>> =>\n    transformResponse<SingleKeyResponse, AccessKey>(\n      sdk.httpClient.get(apiPaths.accessKey.load, {\n        queryParams: { id },\n        token: managementKey,\n      }),\n      (data) => data.key,\n    ),\n  /**\n   * Search all access keys\n   * @param tenantIds Optional tenant ID filter to apply on the search results\n   * @returns An array of found access keys\n   */\n  searchAll: (tenantIds?: string[]): Promise<SdkResponse<AccessKey[]>> =>\n    transformResponse<MultipleKeysResponse, AccessKey[]>(\n      sdk.httpClient.post(apiPaths.accessKey.search, { tenantIds }, { token: managementKey }),\n      (data) => data.keys,\n    ),\n  /**\n   * Update an access key.\n   * @param id Access key ID to load\n   * @param name The updated access key name\n   * @param description Optional updated access key description\n   * @returns The updated access key\n   */\n  update: (id: string, name: string, description?: string): Promise<SdkResponse<AccessKey>> =>\n    transformResponse<SingleKeyResponse, AccessKey>(\n      sdk.httpClient.post(\n        apiPaths.accessKey.update,\n        { id, name, description },\n        { token: managementKey },\n      ),\n      (data) => data.key,\n    ),\n  /**\n   * Deactivate an access key. Deactivated access keys cannot be used until they are\n   * activated again.\n   * @param id Access key ID to deactivate\n   */\n  deactivate: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.accessKey.deactivate, { id }, { token: managementKey }),\n    ),\n  /**\n   * Activate an access key. Only deactivated access keys can be activated again.\n   * @param id Access key ID to activate\n   */\n  activate: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.accessKey.activate, { id }, { token: managementKey }),\n    ),\n  /**\n   * Delete an access key. IMPORTANT: This cannot be undone. Use carefully.\n   * @param id Access key ID to delete\n   */\n  delete: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.accessKey.delete, { id }, { token: managementKey }),\n    ),\n});\n\nexport default withAccessKey;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { FlowResponse, FlowsResponse, Screen, Flow } from './types';\n\nconst WithFlow = (sdk: CoreSdk, managementKey?: string) => ({\n  list: (): Promise<SdkResponse<FlowsResponse>> =>\n    transformResponse(sdk.httpClient.post(apiPaths.flow.list, {}, { token: managementKey })),\n  delete: (flowIds: string[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.flow.delete, { ids: flowIds }, { token: managementKey }),\n    ),\n  export: (flowId: string): Promise<SdkResponse<FlowResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.flow.export, { flowId }, { token: managementKey }),\n    ),\n  import: (flowId: string, flow: Flow, screens?: Screen[]): Promise<SdkResponse<FlowResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.flow.import,\n        { flowId, flow, screens },\n        { token: managementKey },\n      ),\n    ),\n});\n\nexport default WithFlow;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { Theme, ThemeResponse } from './types';\n\nconst WithTheme = (sdk: CoreSdk, managementKey?: string) => ({\n  export: (): Promise<SdkResponse<ThemeResponse>> =>\n    transformResponse(sdk.httpClient.post(apiPaths.theme.export, {}, { token: managementKey })),\n  import: (theme: Theme): Promise<SdkResponse<ThemeResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.theme.import, { theme }, { token: managementKey }),\n    ),\n});\n\nexport default WithTheme;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { AuditSearchOptions, AuditRecord, AuditCreateOptions } from './types';\n\nconst WithAudit = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * Search the audit trail for up to last 30 days based on given optional parameters\n   * @param searchOptions to filter which audit records to return\n   * @returns the audit records array\n   */\n  search: (searchOptions: AuditSearchOptions): Promise<SdkResponse<AuditRecord[]>> => {\n    const body = { ...searchOptions, externalIds: searchOptions.loginIds };\n    delete body.loginIds;\n    return transformResponse(\n      sdk.httpClient.post(apiPaths.audit.search, body, { token: managementKey }),\n      (data) =>\n        data?.audits.map((a) => {\n          const res = {\n            ...a,\n            occurred: parseFloat(a.occurred),\n            loginIds: a.externalIds,\n          };\n          delete res.externalIds;\n          return res;\n        }),\n    );\n  },\n  /**\n   * Create audit event\n   * @param createOptions to define which audit event to create\n   * @returns the audit records array\n   */\n  createEvent: (createOptions: AuditCreateOptions): Promise<SdkResponse<never>> => {\n    const body = { ...createOptions };\n    return transformResponse(\n      sdk.httpClient.post(apiPaths.audit.createEvent, body, { token: managementKey }),\n    );\n  },\n});\n\nexport default WithAudit;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport {\n  AuthzSchema,\n  AuthzNamespace,\n  AuthzRelationDefinition,\n  AuthzRelation,\n  AuthzRelationQuery,\n  AuthzModified,\n} from './types';\n\nconst WithAuthz = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * Save (create or update) the given schema.\n   * In case of update, will update only given namespaces and will not delete namespaces unless upgrade flag is true.\n   * Schema name can be used for projects to track versioning.\n   *\n   * @param schema the schema to save\n   * @param upgrade should we upgrade existing schema or ignore any namespace not provided\n   * @returns standard success or failure response\n   */\n  saveSchema: (schema: AuthzSchema, upgrade: boolean): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.schemaSave, { schema, upgrade }, { token: managementKey }),\n    ),\n  /**\n   * Delete the schema for the project which will also delete all relations.\n   *\n   * @returns standard success or failure response\n   */\n  deleteSchema: (): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.schemaDelete, {}, { token: managementKey }),\n    ),\n  /**\n   * Load the schema for the project.\n   *\n   * @returns the schema associated with the project\n   */\n  loadSchema: (): Promise<SdkResponse<AuthzSchema>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.schemaLoad, {}, { token: managementKey }),\n      (data) => data.schema,\n    ),\n  /**\n   * Save (create or update) the given namespace.\n   * Will not delete relation definitions not mentioned in the namespace.\n   *\n   * @param namespace the namespace to save\n   * @param oldName if we are changing the namespace name, what was the old name we are updating.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  saveNamespace: (\n    namespace: AuthzNamespace,\n    oldName?: string,\n    schemaName?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.nsSave,\n        { namespace, oldName, schemaName },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Delete the given namespace.\n   * Will also delete the relevant relations.\n   *\n   * @param name to delete.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  deleteNamespace: (name: string, schemaName?: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.nsDelete, { name, schemaName }, { token: managementKey }),\n    ),\n  /**\n   * Save (create or update) the given relation definition.\n   *\n   * @param relationDefinition rd to save.\n   * @param namespace that it belongs to.\n   * @param oldName if we are changing the relation definition name, what was the old name we are updating.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  saveRelationDefinition: (\n    relationDefinition: AuthzRelationDefinition,\n    namespace: string,\n    oldName?: string,\n    schemaName?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.rdSave,\n        { relationDefinition, namespace, oldName, schemaName },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Delete the given relation definition.\n   * Will also delete the relevant relations.\n   *\n   * @param name to delete.\n   * @param namespace it belongs to.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  deleteRelationDefinition: (\n    name: string,\n    namespace: string,\n    schemaName?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.rdDelete,\n        { name, namespace, schemaName },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Create the given relations.\n   *\n   * @param relations to create.\n   * @returns standard success or failure response\n   */\n  createRelations: (relations: AuthzRelation[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.reCreate, { relations }, { token: managementKey }),\n    ),\n  /**\n   * Delete the given relations.\n   *\n   * @param relations to delete.\n   * @returns standard success or failure response\n   */\n  deleteRelations: (relations: AuthzRelation[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.reDelete, { relations }, { token: managementKey }),\n    ),\n  /**\n   * Delete the relations for the given resources.\n   *\n   * @param resources resources to delete relations for.\n   * @returns standard success or failure response\n   */\n  deleteRelationsForResources: (resources: string[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.reDeleteResources,\n        { resources },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Query relations to see what relations exists.\n   *\n   * @param relationQueries array of relation queries to check.\n   * @returns array of relation query responses with the boolean flag indicating if relation exists\n   */\n  hasRelations: (\n    relationQueries: AuthzRelationQuery[],\n  ): Promise<SdkResponse<AuthzRelationQuery[]>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.hasRelations,\n        { relationQueries },\n        { token: managementKey },\n      ),\n      (data) => data.relationQueries,\n    ),\n  /**\n   * List all the users that have the given relation definition to the given resource.\n   *\n   * @param resource The resource we are checking\n   * @param relationDefinition The relation definition we are querying\n   * @param namespace The namespace for the relation definition\n   * @returns array of users who have the given relation definition\n   */\n  whoCanAccess: (\n    resource: string,\n    relationDefinition: string,\n    namespace: string,\n  ): Promise<SdkResponse<string[]>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.who,\n        { resource, relationDefinition, namespace },\n        { token: managementKey },\n      ),\n      (data) => data.targets,\n    ),\n  /**\n   * Return the list of all defined relations (not recursive) on the given resource.\n   *\n   * @param resource The resource we are checking\n   * @returns array of relations that exist for the given resource\n   */\n  resourceRelations: (resource: string): Promise<SdkResponse<AuthzRelation[]>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.resource, { resource }, { token: managementKey }),\n      (data) => data.relations,\n    ),\n  /**\n   * Return the list of all defined relations (not recursive) for the given targets.\n   *\n   * @param targets array of targets we want to check\n   * @returns array of relations that exist for the given targets\n   */\n  targetsRelations: (targets: string[]): Promise<SdkResponse<AuthzRelation[]>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.targets, { targets }, { token: managementKey }),\n      (data) => data.relations,\n    ),\n  /**\n   * Return the list of all relations for the given target including derived relations from the schema tree.\n   *\n   * @param target The target to check relations for\n   * @returns array of relations that exist for the given targets\n   */\n  whatCanTargetAccess: (target: string): Promise<SdkResponse<AuthzRelation[]>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.targetAll, { target }, { token: managementKey }),\n      (data) => data.relations,\n    ),\n  /**\n   * Return the list of all relations for the given target including derived relations from the schema tree.\n   *\n   * @param target The target to check relations for\n   * @returns array of relations that exist for the given targets\n   */\n  getModified: (since: Date): Promise<SdkResponse<AuthzModified>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.getModified,\n        { since: since ? since.getTime() : 0 },\n        { token: managementKey },\n      ),\n      (data) => data as AuthzModified,\n    ),\n});\n\nexport default WithAuthz;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport {\n  CreateSSOApplicationResponse,\n  SSOApplication,\n  OidcApplicationOptions,\n  SamlApplicationOptions,\n} from './types';\n\ntype MultipleSSOApplicationResponse = {\n  apps: SSOApplication[];\n};\n\nconst withSSOApplication = (sdk: CoreSdk, managementKey?: string) => ({\n  createOidcApplication: (\n    options: OidcApplicationOptions,\n  ): Promise<SdkResponse<CreateSSOApplicationResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.ssoApplication.oidcCreate,\n        {\n          ...options,\n          enabled: options.enabled ?? true,\n        },\n        { token: managementKey },\n      ),\n    ),\n  createSamlApplication: (\n    options: SamlApplicationOptions,\n  ): Promise<SdkResponse<CreateSSOApplicationResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.ssoApplication.samlCreate,\n        {\n          ...options,\n          enabled: options.enabled ?? true,\n        },\n        { token: managementKey },\n      ),\n    ),\n  updateOidcApplication: (\n    options: OidcApplicationOptions & { id: string },\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.ssoApplication.oidcUpdate,\n        { ...options },\n        { token: managementKey },\n      ),\n    ),\n  updateSamlApplication: (\n    options: SamlApplicationOptions & { id: string },\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.ssoApplication.samlUpdate,\n        { ...options },\n        { token: managementKey },\n      ),\n    ),\n  delete: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.ssoApplication.delete, { id }, { token: managementKey }),\n    ),\n  load: (id: string): Promise<SdkResponse<SSOApplication>> =>\n    transformResponse<SSOApplication, SSOApplication>(\n      sdk.httpClient.get(apiPaths.ssoApplication.load, {\n        queryParams: { id },\n        token: managementKey,\n      }),\n      (data) => data,\n    ),\n  loadAll: (): Promise<SdkResponse<SSOApplication[]>> =>\n    transformResponse<MultipleSSOApplicationResponse, SSOApplication[]>(\n      sdk.httpClient.get(apiPaths.ssoApplication.loadAll, {\n        token: managementKey,\n      }),\n      (data) => data.apps,\n    ),\n});\n\nexport default withSSOApplication;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { PasswordSettings } from './types';\n\nconst withPassword = (sdk: CoreSdk, managementKey?: string) => ({\n  getSettings: (tenantId: string): Promise<SdkResponse<PasswordSettings>> =>\n    transformResponse<PasswordSettings, PasswordSettings>(\n      sdk.httpClient.get(apiPaths.password.settings, {\n        queryParams: { tenantId },\n        token: managementKey,\n      }),\n      (data) => data,\n    ),\n  configureSettings: (tenantId: string, settings: PasswordSettings): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.password.settings,\n        { ...settings, tenantId },\n        {\n          token: managementKey,\n        },\n      ),\n    ),\n});\n\nexport default withPassword;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { CheckResponseRelation, FGARelation, FGASchema } from './types';\n\nconst WithFGA = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * Save (create or update) the given schema.\n   * In case of update, will update only given namespaces and will not delete namespaces unless upgrade flag is true.\n   *\n   * @param schema the schema to save\n   * @returns standard success or failure response\n   */\n  saveSchema: (schema: FGASchema): Promise<SdkResponse<never>> =>\n    transformResponse(sdk.httpClient.post(apiPaths.fga.schema, schema, { token: managementKey })),\n  /**\n   * Delete the schema for the project which will also delete all relations.\n   *\n   * @returns standard success or failure response\n   */\n  deleteSchema: (): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.schemaDelete, {}, { token: managementKey }),\n    ),\n  /**\n   * Create the given relations.\n   *\n   * @param relations to create.\n   * @returns standard success or failure response\n   */\n  createRelations: (relations: FGARelation[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.fga.relations, { tuples: relations }, { token: managementKey }),\n    ),\n\n  /**\n   * Delete the given relations.\n   * This is a bulk operation and will delete all the given relations.\n   *\n   * @param relations to delete.\n   * @returns standard success or failure response\n   */\n\n  deleteRelations: (relations: FGARelation[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.fga.deleteRelations,\n        { tuples: relations },\n        { token: managementKey },\n      ),\n    ),\n\n  /**\n   * Check if the given relations exist.\n   * This is a read-only operation and will not create any relations.\n   * It will return the relations with the boolean flag indicating if relation exists.\n   * This is useful to check if a relation exists before creating it.\n   *\n   * @param relations to check.\n   * @returns array of relations with the boolean flag indicating if relation exists\n   */\n  check: (relations: FGARelation[]): Promise<SdkResponse<CheckResponseRelation[]>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.fga.check, { tuples: relations }, { token: managementKey }),\n      (data) => data.tuples,\n    ),\n});\n\nexport default WithFGA;\n","// eslint-disable-next-line import/prefer-default-export\n/** Common Error Codes */\nexport default {\n  badRequest: 'E011001',\n  missingArguments: 'E011002',\n  invalidRequest: 'E011003',\n  invalidArguments: 'E011004',\n  wrongOTPCode: 'E061102',\n  tooManyOTPAttempts: 'E061103',\n  enchantedLinkPending: 'E062503',\n  userNotFound: 'E062108',\n};\n","import createSdk, {\n  AccessKeyLoginOptions,\n  ExchangeAccessKeyResponse,\n  SdkResponse,\n  wrapWith,\n} from '@descope/core-js-sdk';\nimport { JWK, JWTHeaderParameters, KeyLike, errors, importJWK, jwtVerify } from 'jose';\nimport {\n  permissionsClaimName,\n  refreshTokenCookieName,\n  rolesClaimName,\n  sessionTokenCookieName,\n} from './constants';\nimport fetch from './fetch-polyfill';\nimport { getAuthorizationClaimItems, isUserAssociatedWithTenant, withCookie } from './helpers';\nimport withManagement from './management';\nimport { AuthenticationInfo } from './types';\n\ndeclare const BUILD_VERSION: string;\n\n/** Configuration arguments which include the Descope core SDK args and an optional management key */\ntype NodeSdkArgs = Parameters<typeof createSdk>[0] & {\n  managementKey?: string;\n  publicKey?: string;\n};\n\nconst nodeSdk = ({ managementKey, publicKey, ...config }: NodeSdkArgs) => {\n  const coreSdk = createSdk({\n    fetch,\n    ...config,\n    baseHeaders: {\n      ...config.baseHeaders,\n      'x-descope-sdk-name': 'nodejs',\n      'x-descope-sdk-node-version': process?.versions?.node || '',\n      'x-descope-sdk-version': BUILD_VERSION,\n    },\n  });\n\n  const { projectId, logger } = config;\n\n  const keys: Record<string, KeyLike | Uint8Array> = {};\n\n  /** Fetch the public keys (JWKs) from Descope for the configured project */\n  const fetchKeys = async () => {\n    if (publicKey) {\n      try {\n        const parsedKey = JSON.parse(publicKey);\n        const key = await importJWK(parsedKey);\n        return {\n          [parsedKey.kid]: key,\n        };\n      } catch (e) {\n        logger?.error('Failed to parse the provided public key', e);\n        throw new Error(`Failed to parse public key. Error: ${e}`);\n      }\n    }\n\n    const keysWrapper = await coreSdk.httpClient\n      .get(`v2/keys/${projectId}`)\n      .then((resp) => resp.json());\n    const publicKeys: JWK[] = keysWrapper.keys;\n    if (!Array.isArray(publicKeys)) return {};\n    const kidJwksPairs = await Promise.all(\n      publicKeys.map(async (key) => [key.kid, await importJWK(key)]),\n    );\n\n    return kidJwksPairs.reduce(\n      (acc, [kid, jwk]) => (kid ? { ...acc, [kid.toString()]: jwk } : acc),\n      {},\n    );\n  };\n\n  const management = withManagement(coreSdk, managementKey);\n\n  const sdk = {\n    ...coreSdk,\n\n    // Overrides core-sdk refresh, because the core-sdk exposes queryParams, which is for internal use only\n    refresh: async (token?: string) => coreSdk.refresh(token),\n\n    /**\n     * Provides various APIs for managing a Descope project programmatically. A management key must\n     * be provided as an argument when initializing the SDK to use these APIs. Management keys can be\n     * generated in the Descope console.\n     */\n    management,\n\n    /** Get the key that can validate the given JWT KID in the header. Can retrieve the public key from local cache or from Descope. */\n    async getKey(header: JWTHeaderParameters): Promise<KeyLike | Uint8Array> {\n      if (!header?.kid) throw Error('header.kid must not be empty');\n\n      if (keys[header.kid]) return keys[header.kid];\n\n      // do we need to fetch once or every time?\n      Object.assign(keys, await fetchKeys());\n\n      if (!keys[header.kid]) throw Error('failed to fetch matching key');\n\n      return keys[header.kid];\n    },\n\n    /**\n     * Validate the given JWT with the right key and make sure the issuer is correct\n     * @param jwt the JWT string to parse and validate\n     * @returns AuthenticationInfo with the parsed token and JWT. Will throw an error if validation fails.\n     */\n    async validateJwt(jwt: string): Promise<AuthenticationInfo> {\n      // Do not hard-code the algo because library does not support `None` so all are valid\n      const res = await jwtVerify(jwt, sdk.getKey, { clockTolerance: 5 });\n      const token = res.payload;\n\n      if (token) {\n        token.iss = token.iss?.split('/').pop(); // support both url and project id as issuer\n        if (token.iss !== projectId) {\n          // We must do the verification here, since issuer can be either project ID or URL\n          throw new errors.JWTClaimValidationFailed(\n            'unexpected \"iss\" claim value',\n            'iss',\n            'check_failed',\n          );\n        }\n      }\n\n      return { jwt, token };\n    },\n\n    /**\n     * Validate an active session\n     * @param sessionToken session JWT to validate\n     * @returns AuthenticationInfo promise or throws Error if there is an issue with JWTs\n     */\n    async validateSession(sessionToken: string): Promise<AuthenticationInfo> {\n      if (!sessionToken) throw Error('session token is required for validation');\n\n      try {\n        const token = await sdk.validateJwt(sessionToken);\n        return token;\n      } catch (error) {\n        /* istanbul ignore next */\n        logger?.error('session validation failed', error);\n        throw Error(`session validation failed. Error: ${error}`);\n      }\n    },\n\n    /**\n     * Refresh the session using a refresh token\n     * @param refreshToken refresh JWT to refresh the session with\n     * @returns AuthenticationInfo promise or throws Error if there is an issue with JWTs\n     */\n    async refreshSession(refreshToken: string): Promise<AuthenticationInfo> {\n      if (!refreshToken) throw Error('refresh token is required to refresh a session');\n\n      try {\n        await sdk.validateJwt(refreshToken);\n        const jwtResp = await sdk.refresh(refreshToken);\n        if (jwtResp.ok) {\n          const token = await sdk.validateJwt(jwtResp.data?.sessionJwt);\n          return token;\n        }\n        /* istanbul ignore next */\n        throw Error(jwtResp.error?.errorMessage);\n      } catch (refreshTokenErr) {\n        /* istanbul ignore next */\n        logger?.error('refresh token validation failed', refreshTokenErr);\n        throw Error(`refresh token validation failed, Error: ${refreshTokenErr}`);\n      }\n    },\n\n    /**\n     * Validate session and refresh it if it expired\n     * @param sessionToken session JWT\n     * @param refreshToken refresh JWT\n     * @returns AuthenticationInfo promise or throws Error if there is an issue with JWTs\n     */\n    async validateAndRefreshSession(\n      sessionToken?: string,\n      refreshToken?: string,\n    ): Promise<AuthenticationInfo> {\n      if (!sessionToken && !refreshToken) throw Error('both session and refresh tokens are empty');\n\n      try {\n        const token = await sdk.validateSession(sessionToken);\n        return token;\n      } catch (error) {\n        /* istanbul ignore next */\n        logger?.log(`session validation failed with error ${error} - trying to refresh it`);\n      }\n\n      return sdk.refreshSession(refreshToken);\n    },\n\n    /**\n     * Exchange API key (access key) for a session key\n     * @param accessKey access key to exchange for a session JWT\n     * @param loginOptions Optional advanced controls over login parameters\n     * @returns AuthenticationInfo with session JWT data\n     */\n    async exchangeAccessKey(\n      accessKey: string,\n      loginOptions?: AccessKeyLoginOptions,\n    ): Promise<AuthenticationInfo> {\n      if (!accessKey) throw Error('access key must not be empty');\n\n      let resp: SdkResponse<ExchangeAccessKeyResponse>;\n      try {\n        resp = await sdk.accessKey.exchange(accessKey, loginOptions);\n      } catch (error) {\n        logger?.error('failed to exchange access key', error);\n        throw Error(`could not exchange access key - Failed to exchange. Error: ${error}`);\n      }\n\n      const { sessionJwt } = resp.data;\n      if (!sessionJwt) {\n        logger?.error('failed to parse exchange access key response');\n        throw Error('could not exchange access key');\n      }\n\n      try {\n        const token = await sdk.validateJwt(sessionJwt);\n        return token;\n      } catch (error) {\n        logger?.error('failed to parse jwt from access key', error);\n        throw Error(`could not exchange access key - failed to validate jwt. Error: ${error}`);\n      }\n    },\n\n    /**\n     * Make sure that all given permissions exist on the parsed JWT top level claims\n     * @param authInfo JWT parsed info\n     * @param permissions list of permissions to make sure they exist on te JWT claims\n     * @returns true if all permissions exist, false otherwise\n     */\n    validatePermissions(authInfo: AuthenticationInfo, permissions: string[]): boolean {\n      return sdk.validateTenantPermissions(authInfo, '', permissions);\n    },\n\n    /**\n     * Retrieves the permissions from JWT top level claims that match the specified permissions list\n     * @param authInfo JWT parsed info containing the permissions\n     * @param permissions List of permissions to match against the JWT claims\n     * @returns An array of permissions that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     */\n    getMatchedPermissions(authInfo: AuthenticationInfo, permissions: string[]): string[] {\n      return sdk.getMatchedTenantPermissions(authInfo, '', permissions);\n    },\n\n    /**\n     * Make sure that all given permissions exist on the parsed JWT tenant claims\n     * @param authInfo JWT parsed info\n     * @param tenant tenant to validate the permissions for\n     * @param permissions list of permissions to make sure they exist on te JWT claims\n     * @returns true if all permissions exist, false otherwise\n     */\n    validateTenantPermissions(\n      authInfo: AuthenticationInfo,\n      tenant: string,\n      permissions: string[],\n    ): boolean {\n      // check if user is associated to the tenant\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return false;\n\n      const granted = getAuthorizationClaimItems(authInfo, permissionsClaimName, tenant);\n      return permissions.every((perm) => granted.includes(perm));\n    },\n\n    /**\n     * Retrieves the permissions from JWT tenant claims that match the specified permissions list\n     * @param authInfo JWT parsed info containing the permissions\n     * @param tenant tenant to match the permissions for\n     * @param permissions List of permissions to match against the JWT claims\n     * @returns An array of permissions that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     * */\n    getMatchedTenantPermissions(\n      authInfo: AuthenticationInfo,\n      tenant: string,\n      permissions: string[],\n    ): string[] {\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return [];\n\n      const granted = getAuthorizationClaimItems(authInfo, permissionsClaimName, tenant);\n      return permissions.filter((perm) => granted.includes(perm));\n    },\n\n    /**\n     * Make sure that all given roles exist on the parsed JWT top level claims\n     * @param authInfo JWT parsed info\n     * @param roles list of roles to make sure they exist on te JWT claims\n     * @returns true if all roles exist, false otherwise\n     */\n    validateRoles(authInfo: AuthenticationInfo, roles: string[]): boolean {\n      return sdk.validateTenantRoles(authInfo, '', roles);\n    },\n\n    /**\n     * Retrieves the roles from JWT top level claims that match the specified roles list\n     * @param authInfo JWT parsed info containing the roles\n     * @param roles List of roles to match against the JWT claims\n     * @returns An array of roles that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     */\n    getMatchedRoles(authInfo: AuthenticationInfo, roles: string[]): string[] {\n      return sdk.getMatchedTenantRoles(authInfo, '', roles);\n    },\n\n    /**\n     * Make sure that all given roles exist on the parsed JWT tenant claims\n     * @param authInfo JWT parsed info\n     * @param tenant tenant to validate the roles for\n     * @param roles list of roles to make sure they exist on te JWT claims\n     * @returns true if all roles exist, false otherwise\n     */\n    validateTenantRoles(authInfo: AuthenticationInfo, tenant: string, roles: string[]): boolean {\n      // check if user is associated to the tenant\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return false;\n\n      const membership = getAuthorizationClaimItems(authInfo, rolesClaimName, tenant);\n      return roles.every((role) => membership.includes(role));\n    },\n\n    /**\n     * Retrieves the roles from JWT tenant claims that match the specified roles list\n     * @param authInfo JWT parsed info containing the roles\n     * @param tenant tenant to match the roles for\n     * @param roles List of roles to match against the JWT claims\n     * @returns An array of roles that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     */\n    getMatchedTenantRoles(authInfo: AuthenticationInfo, tenant: string, roles: string[]): string[] {\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return [];\n\n      const membership = getAuthorizationClaimItems(authInfo, rolesClaimName, tenant);\n      return roles.filter((role) => membership.includes(role));\n    },\n  };\n\n  return wrapWith(\n    sdk,\n    [\n      'otp.verify.email',\n      'otp.verify.sms',\n      'otp.verify.voice',\n      'otp.verify.whatsapp',\n      'magicLink.verify',\n      'enchantedLink.signUp',\n      'enchantedLink.signIn',\n      'oauth.exchange',\n      'saml.exchange',\n      'totp.verify',\n      'webauthn.signIn.finish',\n      'webauthn.signUp.finish',\n      'refresh',\n    ] as const,\n    withCookie,\n  );\n};\n\n/** Descope SDK client with delivery methods enum.\n *\n * Please see full documentation at {@link https://docs.descope.com/guides Descope Docs}\n * @example Usage\n *\n * ```js\n * import descopeSdk from '@descope/node-sdk';\n *\n * const myProjectId = 'xxx';\n * const sdk = descopeSdk({ projectId: myProjectId });\n *\n * const userLoginId = 'loginId';\n * sdk.otp.signIn.email(userLoginId);\n * const jwtResponse = sdk.otp.verify.email(userLoginId, codeFromEmail);\n * ```\n */\n\nnodeSdk.RefreshTokenCookieName = refreshTokenCookieName;\nnodeSdk.SessionTokenCookieName = sessionTokenCookieName;\n\nexport default nodeSdk;\nexport type {\n  DeliveryMethod,\n  JWTResponse,\n  OAuthProvider,\n  ResponseData,\n  SdkResponse,\n} from '@descope/core-js-sdk';\nexport * as descopeErrors from './errors';\nexport type { AuthenticationInfo };\n","import { CoreSdk } from '../types';\nimport withUser from './user';\nimport withProject from './project';\nimport withTenant from './tenant';\nimport withJWT from './jwt';\nimport withPermission from './permission';\nimport withRole from './role';\nimport withGroup from './group';\nimport withSSOSettings from './sso';\nimport withAccessKey from './accesskey';\nimport WithFlow from './flow';\nimport WithTheme from './theme';\nimport WithAudit from './audit';\nimport WithAuthz from './authz';\nimport withSSOApplication from './ssoapplication';\nimport withPassword from './password';\nimport WithFGA from './fga';\n\n/** Constructs a higher level Management API that wraps the functions from code-js-sdk */\nconst withManagement = (sdk: CoreSdk, managementKey?: string) => ({\n  user: withUser(sdk, managementKey),\n  project: withProject(sdk, managementKey),\n  accessKey: withAccessKey(sdk, managementKey),\n  tenant: withTenant(sdk, managementKey),\n  ssoApplication: withSSOApplication(sdk, managementKey),\n  sso: withSSOSettings(sdk, managementKey),\n  jwt: withJWT(sdk, managementKey),\n  permission: withPermission(sdk, managementKey),\n  password: withPassword(sdk, managementKey),\n  role: withRole(sdk, managementKey),\n  group: withGroup(sdk, managementKey),\n  flow: WithFlow(sdk, managementKey),\n  theme: WithTheme(sdk, managementKey),\n  audit: WithAudit(sdk, managementKey),\n  authz: WithAuthz(sdk, managementKey),\n  fga: WithFGA(sdk, managementKey),\n});\n\nexport default withManagement;\n"],"names":["_a","globalThis","Headers","patchedFetch","args","forEach","arg","_b","highWaterMark","crossFetch","withCookie","fn","async","resp","data","_d","refreshJwt","rest","__rest","cookies","options","push","cookieDomain","cookieMaxAge","cookiePath","response","headers","get","cookie","name","match","RegExp","getCookieValue","_c","Object","assign","getAuthorizationClaimItems","authInfo","claim","tenant","value","token","Array","isArray","isUserAssociatedWithTenant","apiPaths","create","createTestUser","createBatch","update","patch","delete","deleteAllTestUsers","load","logout","search","searchTestUsers","getProviderToken","updateStatus","updateLoginId","updateEmail","updatePhone","updateDisplayName","updatePicture","updateCustomAttribute","setRole","addRole","removeRole","setSSOApps","addSSOApps","removeSSOApps","addTenant","removeTenant","setPassword","setTemporaryPassword","setActivePassword","expirePassword","removeAllPasskeys","generateOTPForTest","generateMagicLinkForTest","generateEnchantedLinkForTest","generateEmbeddedLink","history","updateName","updateTags","clone","projectsList","exportSnapshot","importSnapshot","validateSnapshot","deactivate","activate","settings","loadAll","searchAll","generateSSOConfigurationLink","oidcCreate","samlCreate","oidcUpdate","samlUpdate","metadata","mapping","settingsv2","oidc","configure","saml","impersonate","list","export","import","loadAllGroups","loadAllGroupsForMember","loadAllGroupMembers","createEvent","schemaSave","schemaDelete","schemaLoad","nsSave","nsDelete","rdSave","rdDelete","reCreate","reDelete","reDeleteResources","hasRelations","who","resource","targets","targetAll","getModified","schema","relations","deleteRelations","check","withUser","sdk","managementKey","loginId","emailOrOptions","phone","displayName","roles","userTenants","customAttributes","picture","verifiedEmail","verifiedPhone","givenName","middleName","familyName","additionalLoginIds","body","email","roleNames","undefined","transformResponse","httpClient","post","user","test","invite","inviteUrl","sendMail","sendSMS","templateId","inviteBatch","users","templateOptions","map","u","res","ssoAppIds","deleteByUserId","userId","queryParams","loadByUserId","logoutUser","logoutUserByUserId","tenantIds","limit","page","testUsersOnly","withTestUser","statuses","emails","phones","searchReq","provider","providerTokenOptions","withRefreshToken","forceRefresh","status","newLoginId","isVerified","verified","attributeKey","attributeValue","setRoles","addRoles","removeRoles","tenantId","setTenantRoles","addTenantRoles","removeTenantRoles","addSSOapps","setSSOapps","removeSSOapps","generateOTPForTestUser","deliveryMethod","loginOptions","generateMagicLinkForTestUser","uri","URI","generateEnchantedLinkForTestUser","customClaims","password","userIds","withProject","tags","environment","listProjects","projects","id","request","files","withTenant","selfProvisioningDomains","createWithId","cascade","tenants","ids","names","tenantNames","tenantSelfProvisioningDomains","getSettings","configureSettings","expireDuration","expireTime","withJWT","jwt","impersonatorId","validateConsent","selectedTenant","withPermission","description","newName","permissions","withRole","permissionNames","withGroup","loginIds","groupId","withSSOSettings","deleteSettings","idpURL","idpCert","entityId","redirectURL","domains","configureMetadata","idpMetadataURL","configureMapping","roleMappings","attributeMapping","configureOIDCSettings","readySettings","userAttrMapping","configureSAMLSettings","redirectUrl","configureSAMLByMetadata","loadSettings","groupsMapping","gm","rm","roleName","role","withAccessKey","keyTenants","permittedIps","key","keys","WithFlow","flowIds","flowId","flow","screens","WithTheme","theme","WithAudit","searchOptions","externalIds","audits","a","occurred","parseFloat","createOptions","WithAuthz","saveSchema","upgrade","deleteSchema","loadSchema","saveNamespace","namespace","oldName","schemaName","deleteNamespace","saveRelationDefinition","relationDefinition","deleteRelationDefinition","createRelations","deleteRelationsForResources","resources","relationQueries","whoCanAccess","resourceRelations","targetsRelations","whatCanTargetAccess","target","since","getTime","withSSOApplication","createOidcApplication","enabled","createSamlApplication","updateOidcApplication","updateSamlApplication","apps","withPassword","WithFGA","tuples","badRequest","missingArguments","invalidRequest","invalidArguments","wrongOTPCode","tooManyOTPAttempts","enchantedLinkPending","userNotFound","nodeSdk","publicKey","config","coreSdk","createSdk","fetch","baseHeaders","process","versions","node","projectId","logger","management","project","accessKey","ssoApplication","sso","permission","group","audit","authz","fga","withManagement","refresh","header","kid","Error","parsedKey","JSON","parse","importJWK","e","error","publicKeys","then","json","Promise","all","reduce","acc","jwk","toString","fetchKeys","jwtVerify","getKey","clockTolerance","payload","iss","split","pop","errors","JWTClaimValidationFailed","sessionToken","validateJwt","refreshToken","jwtResp","ok","sessionJwt","errorMessage","refreshTokenErr","validateSession","log","refreshSession","exchange","validatePermissions","validateTenantPermissions","getMatchedPermissions","getMatchedTenantPermissions","granted","every","perm","includes","filter","validateRoles","validateTenantRoles","getMatchedRoles","getMatchedTenantRoles","membership","wrapWith","RefreshTokenCookieName","SessionTokenCookieName"],"mappings":"4NAEkB,QAAlBA,EAAAC,WAAWC,eAAO,IAAAF,IAAlBC,WAAWC,QAAYA,GAEvB,MAGMC,EAAe,IAAIC,KAGvBA,EAAKC,SAASC,YAERA,GAAsB,iBAARA,YAEhBN,GAAAO,EAACD,GAAYE,+BAAAA,cAVK,UAWnB,IAGIC,KAAcL,ICeVM,EACVC,GACDC,SAAUR,eACR,MAAMS,QAAaF,KAAMP,GAGzB,IAAKS,EAAKC,KACR,OAAOD,EAIT,IAAIE,EAA0BF,EAAKC,MAA/BE,WAAEA,GAAUD,EAAKE,EAAjBC,EAAAH,EAAA,CAAA,eACJ,MAAMI,EAAoB,GAlCP,IAA8BC,EAgDjD,OAZKJ,EASHG,EAAQE,KA5CZ,GCVoC,SDsDoBL,cA5C5BI,OADuBA,EA6CiBH,QA5CxC,EAAAG,EAASE,eAAgB,gBACnDF,aAAA,EAAAA,EAASG,eAAgB,aACjBH,aAAA,EAAAA,EAASI,aAAc,mCAkCZ,QAAbxB,EAAAa,EAAKY,gBAAQ,IAAAzB,OAAA,EAAAA,EAAE0B,QAAQC,IAAI,iBAC7BX,EA3Be,EAACY,EAAmCC,KACzD,MAAMC,EAAQF,eAAAA,EAAQE,MAAMC,OAAO,cAAcF,cACjD,OAAOC,EAAQA,EAAM,GAAK,IAAI,EAyBXE,CACE,QAAbzB,EAAAM,EAAKY,gBAAQ,IAAAlB,OAAA,EAAAA,EAAEmB,QAAQC,IAAI,cChDC,ODmD9BR,EAAQE,KAAoB,QAAfY,EAAApB,EAAKY,gBAAU,IAAAQ,OAAA,EAAAA,EAAAP,QAAQC,IAAI,gBAMhCO,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAtB,GAAM,CAAAC,KAAWoB,OAAAC,OAAAD,OAAAC,OAAA,GAAAtB,EAAKC,MAAM,CAAAE,aAAYG,aAAY,WAUpDiB,EACdC,EACAC,EACAC,WAEA,MAAMC,EAAQD,EAC0C,QAApDhC,EAA6C,QAA7CP,EAAAqC,EAASI,MAAgC,eAAI,IAAAzC,OAAA,EAAAA,EAAAuC,UAAO,IAAAhC,OAAA,EAAAA,EAAG+B,GACvDD,EAASI,MAAMH,GACnB,OAAOI,MAAMC,QAAQH,GAASA,EAAQ,EACxC,CAQgB,SAAAI,EAA2BP,EAA8BE,SACvE,SAAmD,QAA1CvC,EAAAqC,EAASI,MAAgC,eAAC,IAAAzC,OAAA,EAAAA,EAAGuC,GACxD,CEvFA,IAAeM,EACP,CACJC,OAAQ,uBACRC,eAAgB,4BAChBC,YAAa,6BACbC,OAAQ,uBACRC,MAAO,sBACPC,OAAQ,uBACRC,mBAAoB,gCACpBC,KAAM,gBACNC,OAAQ,uBACRC,OAAQ,uBACRC,gBAAiB,4BACjBC,iBAAkB,+BAClBC,aAAc,8BACdC,cAAe,+BACfC,YAAa,6BACbC,YAAa,6BACbC,kBAAmB,4BACnBC,cAAe,+BACfC,sBAAuB,uCACvBC,QAAS,gCACTC,QAAS,gCACTC,WAAY,mCACZC,WAAY,kCACZC,WAAY,kCACZC,cAAe,qCACfC,UAAW,kCACXC,aAAc,qCACdC,YAAa,6BACbC,qBAAsB,uCACtBC,kBAAmB,oCACnBC,eAAgB,gCAChBC,kBAAmB,gCACnBC,mBAAoB,8BACpBC,yBAA0B,oCAC1BC,6BAA8B,wCAC9BC,qBAAsB,oCACtBC,QAAS,yBAtCErC,EAwCJ,CACPsC,WAAY,+BACZC,WAAY,+BACZC,MAAO,yBACPC,aAAc,yBACdC,eAAgB,mCAChBC,eAAgB,mCAChBC,iBAAkB,sCA/CP5C,EAiDF,CACTC,OAAQ,4BACRO,KAAM,qBACNE,OAAQ,4BACRN,OAAQ,4BACRyC,WAAY,gCACZC,SAAU,8BACVxC,OAAQ,6BAxDGN,EA0DL,CACNC,OAAQ,yBACRG,OAAQ,yBACRE,OAAQ,yBACRE,KAAM,kBACNuC,SAAU,2BACVC,QAAS,sBACTC,UAAW,yBACXC,6BAA8B,2CAlEnBlD,EAoEG,CACdmD,WAAY,mCACZC,WAAY,mCACZC,WAAY,mCACZC,WAAY,mCACZhD,OAAQ,8BACRE,KAAM,4BACNwC,QAAS,8BA3EEhD,EA6ER,CACH+C,SAAU,wBACVQ,SAAU,wBACVC,QAAS,uBACTC,WAAY,wBACZC,KAAM,CACJC,UAAW,qBAEbC,KAAM,CACJD,UAAW,oBACXJ,SAAU,+BAvFDvD,EA0FR,CACHI,OAAQ,sBACRyD,YAAa,wBA5FF7D,EA8FH,CACR+C,SAAU,8BA/FC/C,EAiGD,CACVC,OAAQ,6BACRG,OAAQ,6BACRE,OAAQ,6BACR0C,QAAS,2BArGEhD,EAuGP,CACJC,OAAQ,uBACRG,OAAQ,uBACRE,OAAQ,uBACR0C,QAAS,oBACTtC,OAAQ,wBA5GGV,EA8GP,CACJ8D,KAAM,qBACNxD,OAAQ,uBACRyD,OAAQ,uBACRC,OAAQ,wBAlHGhE,EAoHN,CACL+D,OAAQ,wBACRC,OAAQ,yBAtHGhE,EAwHN,CACLiE,cAAe,qBACfC,uBAAwB,4BACxBC,oBAAqB,0BA3HVnE,EA6HN,CACLU,OAAQ,wBACR0D,YAAa,wBA/HFpE,EAiIN,CACLqE,WAAY,6BACZC,aAAc,+BACdC,WAAY,6BACZC,OAAQ,yBACRC,SAAU,2BACVC,OAAQ,yBACRC,SAAU,2BACVC,SAAU,2BACVC,SAAU,2BACVC,kBAAmB,oCACnBC,aAAc,wBACdC,IAAK,wBACLC,SAAU,6BACVC,QAAS,4BACTC,UAAW,8BACXC,YAAa,8BAjJFpF,EAmJR,CACHqF,OAAQ,sBACRC,UAAW,yBACXC,gBAAiB,gCACjBC,MAAO,sBClGX,MAAMC,EAAW,CAACC,EAAcC,KAyWvB,CACL1F,OAtVF,SACE2F,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAKA,MAAMC,EACsB,iBAAnBb,EACH,CACED,UACAe,MAAOd,EACPC,QACAC,cACAO,YACAC,aACAC,aACAI,UAAWZ,EACXC,cACAC,mBACAC,UACAC,gBACAC,gBACAI,mDAGAb,WACGC,GACH,CAAAe,UAAWf,aAAA,EAAAA,EAAgBG,MAC3BA,WAAOa,IAEf,OAAOC,EACLpB,EAAIqB,WAAWC,KAAKhH,EAAcC,OAAQyG,EAAM,CAAE9G,MAAO+F,KACxD1H,GAASA,EAAKgJ,MAElB,EAkTC/G,eAzRF,SACE0F,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAKA,MAAMC,EACsB,iBAAnBb,EACH,CACED,UACAe,MAAOd,EACPC,QACAC,cACAO,YACAC,aACAC,aACAI,UAAWZ,EACXC,cACAC,mBACAC,UACAC,gBACAC,gBACAI,qBACAS,MAAM,GAET7H,OAAAC,OAAAD,OAAAC,OAAA,CACGsG,WACGC,IACHe,UAAWf,aAAc,EAAdA,EAAgBG,MAC3BA,WAAOa,EACPK,MAAM,IAEd,OAAOJ,EACLpB,EAAIqB,WAAWC,KAAKhH,EAAcE,eAAgBwG,EAAM,CAAE9G,MAAO+F,KAChE1H,GAASA,EAAKgJ,MAElB,EAyOCE,OAtMF,SACEvB,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAe,EACAC,EACAC,EACAhB,EACAC,EACAC,EACAC,EACAc,GAKA,MAAMb,EACsB,iBAAnBb,EACH,CACED,UACAe,MAAOd,EACPC,QACAC,cACAO,YACAC,aACAC,aACAI,UAAWZ,EACXC,cACAkB,QAAQ,EACRjB,mBACAC,UACAC,gBACAC,gBACAe,YACAC,WACAC,UACAb,qBACAc,cAEHlI,OAAAC,OAAAD,OAAAC,OAAA,CACGsG,WACGC,IACHe,UAAWf,aAAc,EAAdA,EAAgBG,MAC3BA,WAAOa,EACPM,QAAQ,IAEhB,OAAOL,EACLpB,EAAIqB,WAAWC,KAAKhH,EAAcC,OAAQyG,EAAM,CAAE9G,MAAO+F,KACxD1H,GAASA,EAAKgJ,MAElB,EA8ICO,YAAa,CACXC,EACAL,EACAC,EACAC,EACAI,EACAH,IAEAT,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcG,YACd,CACEsH,MAAOA,EAAME,KAAKC,IAChB,MAAMC,EACDxI,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAsI,GACH,CAAAhB,UAAWgB,EAAE5B,QAGf,cADO6B,EAAI7B,MACJ6B,CAAG,IAEZV,QAAQ,EACRC,YACAC,WACAC,UACAI,kBACAH,cAEF,CAAE3H,MAAO+F,KAEV1H,GAASA,IAEdmC,OAvJF,SACEwF,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAKA,MAAMC,EACsB,iBAAnBb,EACH,CACED,UACAe,MAAOd,EACPC,QACAC,cACAO,YACAC,aACAC,aACAI,UAAWZ,EACXC,cACAC,mBACAC,UACAC,gBACAC,gBACAI,mDAGAb,WACGC,GACH,CAAAe,UAAWf,aAAA,EAAAA,EAAgBG,MAC3BA,WAAOa,IAEf,OAAOC,EACLpB,EAAIqB,WAAWC,KAAKhH,EAAcI,OAAQsG,EAAM,CAAE9G,MAAO+F,KACxD1H,GAASA,EAAKgJ,MAElB,EAyGC5G,MAjGF,SAAeuF,EAAiBrH,GAC9B,MAAMmI,EAAO,CACXd,WA2CF,YAxCsBiB,IAAlBtI,EAAQoI,QACVD,EAAKC,MAAQpI,EAAQoI,YAEDE,IAAlBtI,EAAQuH,QACVY,EAAKZ,MAAQvH,EAAQuH,YAEKe,IAAxBtI,EAAQwH,cACVW,EAAKX,YAAcxH,EAAQwH,kBAEHc,IAAtBtI,EAAQ+H,YACVI,EAAKJ,UAAY/H,EAAQ+H,gBAEAO,IAAvBtI,EAAQgI,aACVG,EAAKH,WAAahI,EAAQgI,iBAEDM,IAAvBtI,EAAQiI,aACVE,EAAKF,WAAajI,EAAQiI,iBAENK,IAAlBtI,EAAQyH,QACVU,EAAKE,UAAYrI,EAAQyH,YAECa,IAAxBtI,EAAQ0H,cACVS,EAAKT,YAAc1H,EAAQ0H,kBAEIY,IAA7BtI,EAAQ2H,mBACVQ,EAAKR,iBAAmB3H,EAAQ2H,uBAEVW,IAApBtI,EAAQ4H,UACVO,EAAKP,QAAU5H,EAAQ4H,cAEKU,IAA1BtI,EAAQ6H,gBACVM,EAAKN,cAAgB7H,EAAQ6H,oBAEDS,IAA1BtI,EAAQ8H,gBACVK,EAAKL,cAAgB9H,EAAQ8H,oBAELQ,IAAtBtI,EAAQuJ,YACVpB,EAAKoB,UAAYvJ,EAAQuJ,WAGpBhB,EACLpB,EAAIqB,WAAW1G,MAAML,EAAcK,MAAOqG,EAAM,CAAE9G,MAAO+F,KACxD1H,GAASA,EAAKgJ,MAElB,EAqDC3G,OAASsF,GACPkB,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAcM,OAAQ,CAAEsF,WAAW,CAAEhG,MAAO+F,KAOpEoC,eAAiBC,GACflB,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAcM,OAAQ,CAAE0H,UAAU,CAAEpI,MAAO+F,KAKnEpF,mBAAoB,IAClBuG,EACEpB,EAAIqB,WAAWzG,OAAON,EAAcO,mBAAoB,CAAEX,MAAO+F,KAErEnF,KAAOoF,GACLkB,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAcQ,KAAM,CACrCyH,YAAa,CAAErC,WACfhG,MAAO+F,KAER1H,GAASA,EAAKgJ,OAQnBiB,aAAeF,GACblB,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAcQ,KAAM,CACrCyH,YAAa,CAAED,UACfpI,MAAO+F,KAER1H,GAASA,EAAKgJ,OAOnBkB,WAAavC,GACXkB,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAcS,OAAQ,CAAEmF,WAAW,CAAEhG,MAAO+F,KAQpEyC,mBAAqBJ,GACnBlB,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAcS,OAAQ,CAAEuH,UAAU,CAAEpI,MAAO+F,KAcnE1C,UAAW,CACToF,EACArC,EACAsC,EACAC,EACAC,EACAC,EACAvC,EACAwC,EACAC,EACAC,IAEA9B,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcU,OACd,CACE2H,YACAzB,UAAWZ,EACXsC,QACAC,OACAC,gBACAC,eACAvC,mBACAwC,WACAC,SACAC,UAEF,CAAEhJ,MAAO+F,KAEV1H,GAASA,EAAKwJ,QAEnB9G,gBAAkBkI,GAChB/B,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcW,gBAETtB,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAuJ,GACH,CAAAJ,cAAc,EACdD,eAAe,EACf5B,UAAWiC,EAAU7C,MACrBA,WAAOa,IAET,CAAEjH,MAAO+F,KAEV1H,GAASA,EAAKwJ,QAEnB/G,OAASmI,GACP/B,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcU,OAETrB,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAuJ,GACH,CAAAjC,UAAWiC,EAAU7C,MACrBA,WAAOa,IAET,CAAEjH,MAAO+F,KAEV1H,GAASA,EAAKwJ,QAanB7G,iBAAkB,CAChBgF,EACAkD,EACAC,IAEAjC,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAcY,iBAAkB,CACjDqH,YAAa,CACXrC,UACAkD,WACAE,kBAAkBD,eAAAA,EAAsBC,kBAAmB,OAAS,QACpEC,cAAcF,eAAAA,EAAsBE,cAAe,OAAS,SAE9DrJ,MAAO+F,KAER1H,GAASA,IAEd6E,SAAW8C,GACTkB,EACEpB,EAAIqB,WAAWC,KACbhH,EAAca,aACd,CAAE+E,UAASsD,OAAQ,WACnB,CAAEtJ,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnBpE,WAAa+C,GACXkB,EACEpB,EAAIqB,WAAWC,KACbhH,EAAca,aACd,CAAE+E,UAASsD,OAAQ,YACnB,CAAEtJ,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnBnG,cAAe,CAAC8E,EAAiBuD,IAC/BrC,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcc,cACd,CAAE8E,UAASuD,cACX,CAAEvJ,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnBlG,YAAa,CACX6E,EACAe,EACAyC,IAEAtC,EACEpB,EAAIqB,WAAWC,KACbhH,EAAce,YACd,CAAE6E,UAASe,QAAO0C,SAAUD,GAC5B,CAAExJ,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnBjG,YAAa,CACX4E,EACAE,EACAsD,IAEAtC,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcgB,YACd,CAAE4E,UAASE,QAAOuD,SAAUD,GAC5B,CAAExJ,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnBhG,kBAAmB,CACjB2E,EACAG,EACAO,EACAC,EACAC,IAEAM,EACEpB,EAAIqB,WAAWC,KACbhH,EAAciB,kBACd,CAAE2E,UAASG,cAAaO,YAAWC,aAAYC,cAC/C,CAAE5G,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnB/F,cAAe,CAAC0E,EAAiBO,IAC/BW,EACEpB,EAAIqB,WAAWC,KACbhH,EAAckB,cACd,CAAE0E,UAASO,WACX,CAAEvG,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnB9F,sBAAuB,CACrByE,EACA0D,EACAC,IAEAzC,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcmB,sBACd,CAAEyE,UAAS0D,eAAcC,kBACzB,CAAE3J,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnBuC,SAAU,CAAC5D,EAAiBI,IAC1Bc,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcoB,QACd,CAAEwE,UAASgB,UAAWZ,GACtB,CAAEpG,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnBwC,SAAU,CAAC7D,EAAiBI,IAC1Bc,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcqB,QACd,CAAEuE,UAASgB,UAAWZ,GACtB,CAAEpG,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnByC,YAAa,CAAC9D,EAAiBI,IAC7Bc,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcsB,WACd,CAAEsE,UAASgB,UAAWZ,GACtB,CAAEpG,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnBvF,UAAW,CAACkE,EAAiB+D,IAC3B7C,EACEpB,EAAIqB,WAAWC,KACbhH,EAAc0B,UACd,CAAEkE,UAAS+D,YACX,CAAE/J,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnBtF,aAAc,CAACiE,EAAiB+D,IAC9B7C,EACEpB,EAAIqB,WAAWC,KACbhH,EAAc2B,aACd,CAAEiE,UAAS+D,YACX,CAAE/J,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnB2C,eAAgB,CACdhE,EACA+D,EACA3D,IAEAc,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcoB,QACd,CAAEwE,UAAS+D,WAAU/C,UAAWZ,GAChC,CAAEpG,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnB4C,eAAgB,CACdjE,EACA+D,EACA3D,IAEAc,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcqB,QACd,CAAEuE,UAAS+D,WAAU/C,UAAWZ,GAChC,CAAEpG,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnB6C,kBAAmB,CACjBlE,EACA+D,EACA3D,IAEAc,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcsB,WACd,CAAEsE,UAAS+D,WAAU/C,UAAWZ,GAChC,CAAEpG,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnB8C,WAAY,CAACnE,EAAiBkC,IAC5BhB,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcwB,WACd,CAAEoE,UAASkC,aACX,CAAElI,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnB+C,WAAY,CAACpE,EAAiBkC,IAC5BhB,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcuB,WACd,CAAEqE,UAASkC,aACX,CAAElI,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAEnBgD,cAAe,CAACrE,EAAiBkC,IAC/BhB,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcyB,cACd,CAAEmE,UAASkC,aACX,CAAElI,MAAO+F,KAEV1H,GAASA,EAAKgJ,OAcnBiD,uBAAwB,CACtBC,EACAvE,EACAwE,IAEAtD,EACEpB,EAAIqB,WAAWC,KACbhH,EAAciC,mBACd,CAAEkI,iBAAgBvE,UAASwE,gBAC3B,CAAExK,MAAO+F,KAEV1H,GAASA,IAedoM,6BAA8B,CAC5BF,EACAvE,EACA0E,EACAF,IAEAtD,EACEpB,EAAIqB,WAAWC,KACbhH,EAAckC,yBACd,CAAEiI,iBAAgBvE,UAAS2E,IAAKD,EAAKF,gBACrC,CAAExK,MAAO+F,KAEV1H,GAASA,IAcduM,iCAAkC,CAChC5E,EACA0E,EACAF,IAEAtD,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcmC,6BACd,CAAEyD,UAAS2E,IAAKD,EAAKF,gBACrB,CAAExK,MAAO+F,KAEV1H,GAASA,IAGdmE,qBAAsB,CACpBwD,EACA6E,IAEA3D,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcoC,qBACd,CAAEwD,UAAS6E,gBACX,CAAE7K,MAAO+F,KAEV1H,GAASA,IAWd4D,qBAAsB,CAAC+D,EAAiB8E,IACtC5D,EACEpB,EAAIqB,WAAWC,KACbhH,EAAc6B,qBACd,CAAE+D,UAAS8E,YACX,CAAE9K,MAAO+F,KAEV1H,GAASA,IAQd6D,kBAAmB,CAAC8D,EAAiB8E,IACnC5D,EACEpB,EAAIqB,WAAWC,KACbhH,EAAc8B,kBACd,CAAE8D,UAAS8E,YACX,CAAE9K,MAAO+F,KAEV1H,GAASA,IAWd2D,YAAa,CAACgE,EAAiB8E,IAC7B5D,EACEpB,EAAIqB,WAAWC,KACbhH,EAAc4B,YACd,CAAEgE,UAAS8E,YACX,CAAE9K,MAAO+F,KAEV1H,GAASA,IASd8D,eAAiB6D,GACfkB,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAc+B,eAAgB,CAAE6D,WAAW,CAAEhG,MAAO+F,KACvE1H,GAASA,IASd+D,kBAAoB4D,GAClBkB,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAcgC,kBAAmB,CAAE4D,WAAW,CAAEhG,MAAO+F,KAC1E1H,GAASA,IAOdoE,QAAUsI,GACR7D,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAcqC,QAASsI,EAAS,CAAE/K,MAAO+F,KAC5D1H,GAASA,MCv9BZ2M,EAAc,CAAClF,EAAcC,KAA4B,CAK7DrD,WAAatD,GACX8H,EACEpB,EAAIqB,WAAWC,KACbhH,EAAiBsC,WACjB,CACEtD,QAEF,CAAEY,MAAO+F,KAQfpD,WAAasI,GACX/D,EACEpB,EAAIqB,WAAWC,KACbhH,EAAiBuC,WACjB,CACEsI,QAEF,CAAEjL,MAAO+F,KAYfnD,MAAO,CACLxD,EACA8L,EACAD,IAEA/D,EACEpB,EAAIqB,WAAWC,KACbhH,EAAiBwC,MACjB,CACExD,OACA8L,cACAD,QAEF,CAAEjL,MAAO+F,KAQfoF,aAAchN,SACZ+I,EACEpB,EAAIqB,WAAWC,KACbhH,EAAiByC,aACjB,GACA,CACE7C,MAAO+F,KAGV1H,GACCA,EAAK+M,SAASrD,KAAI,EAAGsD,KAAIjM,OAAM8L,cAAaD,WAAY,CACtDI,KACAjM,OACA8L,cACAD,aAqBRnI,eAAgB,IACdoE,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAiB0C,eAAgB,CAAE,EAAE,CAAE9C,MAAO+F,KAwBtEhD,eAAiBuI,GACfpE,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAiB2C,eAAgBuI,EAAS,CAAEtL,MAAO+F,KAsB3E/C,iBACEsI,GAEApE,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAiB4C,iBAAkBsI,EAAS,CAAEtL,MAAO+F,KAM7E5B,OAAQ,IACN+C,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAiB0C,eAAgB,CAAA,EAAI,CAAE9C,MAAO+F,KACjE1H,GAASA,EAAKkN,QAMnBnH,OAASmH,GACPrE,EACEpB,EAAIqB,WAAWC,KACbhH,EAAiB2C,eACjB,CACEwI,SAEF,CAAEvL,MAAO+F,OC7KXyF,EAAa,CAAC1F,EAAcC,KAA4B,CAC5D1F,OAAQ,CACNjB,EACAqM,EACAnF,IAEAY,EACEpB,EAAIqB,WAAWC,KACbhH,EAAgBC,OAChB,CAAEjB,OAAMqM,0BAAyBnF,oBACjC,CAAEtG,MAAO+F,KAGf2F,aAAc,CACZL,EACAjM,EACAqM,EACAnF,IAEAY,EACEpB,EAAIqB,WAAWC,KACbhH,EAAgBC,OAChB,CAAEgL,KAAIjM,OAAMqM,0BAAyBnF,oBACrC,CAAEtG,MAAO+F,KAGfvF,OAAQ,CACN6K,EACAjM,EACAqM,EACAnF,IAEAY,EACEpB,EAAIqB,WAAWC,KACbhH,EAAgBI,OAChB,CAAE6K,KAAIjM,OAAMqM,0BAAyBnF,oBACrC,CAAEtG,MAAO+F,KAGfrF,OAAQ,CAAC2K,EAAYM,IACnBzE,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAgBM,OAAQ,CAAE2K,KAAIM,WAAW,CAAE3L,MAAO+F,KAE1EnF,KAAOyK,GACLnE,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAgBQ,KAAM,CACvCyH,YAAa,CAAEgD,MACfrL,MAAO+F,KAER1H,GAASA,IAEd+E,QAAS,IACP8D,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAgBgD,QAAS,CAC1CpD,MAAO+F,KAER1H,GAASA,EAAKuN,UAEnBvI,UAAW,CACTwI,EACAC,EACAL,EACAnF,IAEAY,EACEpB,EAAIqB,WAAWC,KACbhH,EAAgBiD,UAChB,CACEoF,UAAWoD,EACXE,YAAaD,EACbE,8BAA+BP,EAC/BnF,oBAEF,CAAEtG,MAAO+F,KAEV1H,GAASA,EAAKuN,UAEnBK,YAAclC,GACZ7C,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAgB+C,SAAU,CAC3CkF,YAAa,CAAEgD,GAAItB,GACnB/J,MAAO+F,KAER1H,GAASA,IAEd6N,kBAAmB,CAACnC,EAAkB5G,IACpC+D,EACEpB,EAAIqB,WAAWC,KACbhH,EAAgB+C,SACX1D,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAyD,GAAU,CAAA4G,aACf,CACE/J,MAAO+F,KAIfzC,6BAA8B,CAC5ByG,EACAoC,IAEAjF,EACEpB,EAAIqB,WAAWC,KACbhH,EAAgBkD,6BAChB,CAAEyG,WAAUqC,WAAYD,GACxB,CACEnM,MAAO+F,KAGV1H,GAASA,MCrHVgO,EAAU,CAACvG,EAAcC,KAA4B,CACzDvF,OAAQ,CACN8L,EACAzB,IAEA3D,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAaI,OAAQ,CAAE8L,MAAKzB,gBAAgB,CAAE7K,MAAO+F,KAE7E9B,YAAa,CACXsI,EACAvG,EACAwG,EACA3B,EACA4B,IAEAvF,EACEpB,EAAIqB,WAAWC,KACbhH,EAAa6D,YACb,CAAEsI,iBAAgBvG,UAASwG,kBAAiB3B,eAAc4B,kBAC1D,CAAEzM,MAAO+F,OCfX2G,EAAiB,CAAC5G,EAAcC,KAA4B,CAChE1F,OAAQ,CAACjB,EAAcuN,IACrBzF,EACEpB,EAAIqB,WAAWC,KACbhH,EAAoBC,OACpB,CAAEjB,OAAMuN,eACR,CAAE3M,MAAO+F,KAGfvF,OAAQ,CAACpB,EAAcwN,EAAiBD,IACtCzF,EACEpB,EAAIqB,WAAWC,KACbhH,EAAoBI,OACpB,CAAEpB,OAAMwN,UAASD,eACjB,CAAE3M,MAAO+F,KAGfrF,OAAStB,GACP8H,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAoBM,OAAQ,CAAEtB,QAAQ,CAAEY,MAAO+F,KAEvE3C,QAAS,IACP8D,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAoBgD,QAAS,CAC9CpD,MAAO+F,KAER1H,GAASA,EAAKwO,gBC1BfC,EAAW,CAAChH,EAAcC,KAA4B,CAC1D1F,OAAQ,CACNjB,EACAuN,EACAI,EACAhD,IAEA7C,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcC,OACd,CAAEjB,OAAMuN,cAAaI,kBAAiBhD,YACtC,CAAE/J,MAAO+F,KAGfvF,OAAQ,CACNpB,EACAwN,EACAD,EACAI,EACAhD,IAEA7C,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcI,OACd,CAAEpB,OAAMwN,UAASD,cAAaI,kBAAiBhD,YAC/C,CAAE/J,MAAO+F,KAGfrF,OAAQ,CAACtB,EAAc2K,IACrB7C,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAcM,OAAQ,CAAEtB,OAAM2K,YAAY,CAAE/J,MAAO+F,KAE3E3C,QAAS,IACP8D,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAcgD,QAAS,CACxCpD,MAAO+F,KAER1H,GAASA,EAAK+H,QAEnBtF,OAASnC,GACPuI,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAcU,OAAQnC,EAAS,CACjDqB,MAAO+F,KAER1H,GAASA,EAAK+H,UChDf4G,EAAY,CAAClH,EAAcC,KAA4B,CAM3D1B,cAAgB0F,GACd7C,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAeiE,cAAe,CAAE0F,YAAY,CAAE/J,MAAO+F,KAU7EzB,uBAAwB,CACtByF,EACAgB,EACAkC,IAEA/F,EACEpB,EAAIqB,WAAWC,KACbhH,EAAekE,uBACf,CAAEyF,WAAUkD,WAAUlC,WACtB,CAAE/K,MAAO+F,KAUfxB,oBAAqB,CAACwF,EAAkBmD,IACtChG,EACEpB,EAAIqB,WAAWC,KACbhH,EAAemE,oBACf,CAAEwF,WAAUmD,WACZ,CAAElN,MAAO+F,OClCXoH,EAAkB,CAACrH,EAAcC,KAA4B,CAIjEkG,YAAclC,GACZ7C,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAa+C,SAAU,CACxCkF,YAAa,CAAE0B,YACf/J,MAAO+F,KAER1H,GAASA,IAEd+O,eAAiBrD,GACf7C,EACEpB,EAAIqB,WAAWzG,OAAON,EAAa+C,SAAU,CAC3CkF,YAAa,CAAE0B,YACf/J,MAAO+F,KAMbmG,kBAAmB,CACjBnC,EACAsD,EACAC,EACAC,EACAC,EACAC,IAEAvG,EACEpB,EAAIqB,WAAWC,KACbhH,EAAa+C,SACb,CAAE4G,WAAUsD,SAAQE,WAAUD,UAASE,cAAaC,WACpD,CAAEzN,MAAO+F,KAMf2H,kBAAmB,CACjB3D,EACA4D,EACAH,EACAC,IAEAvG,EACEpB,EAAIqB,WAAWC,KACbhH,EAAauD,SACb,CAAEoG,WAAU4D,iBAAgBH,cAAaC,WACzC,CAAEzN,MAAO+F,KAGf6H,iBAAkB,CAChB7D,EACA8D,EACAC,IAEA5G,EACEpB,EAAIqB,WAAWC,KACbhH,EAAawD,QACb,CAAEmG,WAAU8D,eAAcC,oBAC1B,CAAE9N,MAAO+F,KAGfgI,sBAAuB,CACrBhE,EACA5G,EACAsK,KAEA,MAAMO,EAAqBvO,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAyD,GAAU,CAAA8K,gBAAiB9K,EAAS2K,mBAE/D,cADOE,EAAcF,iBACd5G,EACLpB,EAAIqB,WAAWC,KACbhH,EAAa0D,KAAKC,UAClB,CACEgG,WACA5G,SAAU6K,EACVP,WAEF,CAAEzN,MAAO+F,IAEZ,EAEHmI,sBAAuB,CACrBnE,EACA5G,EACAgL,EACAV,IAEAvG,EACEpB,EAAIqB,WAAWC,KACbhH,EAAa4D,KAAKD,UAClB,CAAEgG,WAAU5G,WAAUgL,cAAaV,WACnC,CAAEzN,MAAO+F,KAGfqI,wBAAyB,CACvBrE,EACA5G,EACAgL,EACAV,IAEAvG,EACEpB,EAAIqB,WAAWC,KACbhH,EAAa4D,KAAKL,SAClB,CAAEoG,WAAU5G,WAAUgL,cAAaV,WACnC,CAAEzN,MAAO+F,KAGfsI,aAAetE,GACb7C,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAayD,WAAY,CAC1CwE,YAAa,CAAE0B,YACf/J,MAAO+F,KAER1H,YACC,MAAM2P,EAAgB3P,EAgBtB,OAfI2P,EAAclK,OAChBkK,EAAclK,KACTrE,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAsO,EAAclK,MAAI,CACrBgK,iBAAkBE,EAAclK,KAAKmK,yBAEhCD,EAAclK,KAAKmK,kBAEN,UAAlBD,EAAchK,YAAI,IAAAzG,OAAA,EAAAA,EAAE+Q,iBACtBN,EAAchK,KAAKsK,cAAkC,UAAlBN,EAAchK,YAAI,IAAAlG,OAAA,EAAAA,EAAEwQ,cAAcvG,KAAKwG,IACxE,MAAMC,EAAKD,EAGX,OAFAC,EAAGC,SAAWD,EAAGE,KAAKtP,YACfoP,EAAGE,KACHF,CAAE,KAGNR,CAAa,MCrItBW,EAAgB,CAAC7I,EAAcC,KAA4B,CAa/D1F,OAAQ,CACNjB,EACAgN,EACAhG,EACAwI,EACAxG,EACAyC,EACA8B,EACAkC,IAEA3H,EACEpB,EAAIqB,WAAWC,KACbhH,EAAmBC,OACnB,CACEjB,OACAgN,aACApF,UAAWZ,EACXwI,aACAxG,SACAyC,eACA8B,cACAkC,gBAEF,CAAE7O,MAAO+F,KAQfnF,KAAOyK,GACLnE,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAmBQ,KAAM,CAC1CyH,YAAa,CAAEgD,MACfrL,MAAO+F,KAER1H,GAASA,EAAKyQ,MAOnBzL,UAAYoF,GACVvB,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAmBU,OAAQ,CAAE2H,aAAa,CAAEzI,MAAO+F,KACtE1H,GAASA,EAAK0Q,OASnBvO,OAAQ,CAAC6K,EAAYjM,EAAcuN,IACjCzF,EACEpB,EAAIqB,WAAWC,KACbhH,EAAmBI,OACnB,CAAE6K,KAAIjM,OAAMuN,eACZ,CAAE3M,MAAO+F,KAEV1H,GAASA,EAAKyQ,MAOnB7L,WAAaoI,GACXnE,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAmB6C,WAAY,CAAEoI,MAAM,CAAErL,MAAO+F,KAMxE7C,SAAWmI,GACTnE,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAmB8C,SAAU,CAAEmI,MAAM,CAAErL,MAAO+F,KAMtErF,OAAS2K,GACPnE,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAmBM,OAAQ,CAAE2K,MAAM,CAAErL,MAAO+F,OC7GhEiJ,EAAW,CAAClJ,EAAcC,KAA4B,CAC1D7B,KAAM,IACJgD,EAAkBpB,EAAIqB,WAAWC,KAAKhH,EAAc8D,KAAM,CAAE,EAAE,CAAElE,MAAO+F,KACzErF,OAASuO,GACP/H,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAcM,OAAQ,CAAEmL,IAAKoD,GAAW,CAAEjP,MAAO+F,KAEzE5B,OAAS+K,GACPhI,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAc+D,OAAQ,CAAE+K,UAAU,CAAElP,MAAO+F,KAEnE3B,OAAQ,CAAC8K,EAAgBC,EAAYC,IACnClI,EACEpB,EAAIqB,WAAWC,KACbhH,EAAcgE,OACd,CAAE8K,SAAQC,OAAMC,WAChB,CAAEpP,MAAO+F,OChBXsJ,EAAY,CAACvJ,EAAcC,KAA4B,CAC3D5B,OAAQ,IACN+C,EAAkBpB,EAAIqB,WAAWC,KAAKhH,EAAe+D,OAAQ,CAAE,EAAE,CAAEnE,MAAO+F,KAC5E3B,OAASkL,GACPpI,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAegE,OAAQ,CAAEkL,SAAS,CAAEtP,MAAO+F,OCL/DwJ,EAAY,CAACzJ,EAAcC,KAA4B,CAM3DjF,OAAS0O,IACP,MAAM1I,EAAYrH,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAA8P,GAAe,CAAAC,YAAaD,EAAcvC,WAE5D,cADOnG,EAAKmG,SACL/F,EACLpB,EAAIqB,WAAWC,KAAKhH,EAAeU,OAAQgG,EAAM,CAAE9G,MAAO+F,KACzD1H,GACCA,eAAAA,EAAMqR,OAAO3H,KAAK4H,IAChB,MAAM1H,EACDxI,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAiQ,IACHC,SAAUC,WAAWF,EAAEC,UACvB3C,SAAU0C,EAAEF,cAGd,cADOxH,EAAIwH,YACJxH,CAAG,KAEf,EAOHzD,YAAcsL,IACZ,MAAMhJ,EAAIrH,OAAAC,OAAA,CAAA,EAAQoQ,GAClB,OAAO5I,EACLpB,EAAIqB,WAAWC,KAAKhH,EAAeoE,YAAasC,EAAM,CAAE9G,MAAO+F,IAChE,ICzBCgK,EAAY,CAACjK,EAAcC,KAA4B,CAU3DiK,WAAY,CAACvK,EAAqBwK,IAChC/I,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAeqE,WAAY,CAAEgB,SAAQwK,WAAW,CAAEjQ,MAAO+F,KAOjFmK,aAAc,IACZhJ,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAesE,aAAc,CAAE,EAAE,CAAE1E,MAAO+F,KAOlEoK,WAAY,IACVjJ,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAeuE,WAAY,CAAA,EAAI,CAAE3E,MAAO+F,KAC3D1H,GAASA,EAAKoH,SAWnB2K,cAAe,CACbC,EACAC,EACAC,IAEArJ,EACEpB,EAAIqB,WAAWC,KACbhH,EAAewE,OACf,CAAEyL,YAAWC,UAASC,cACtB,CAAEvQ,MAAO+F,KAWfyK,gBAAiB,CAACpR,EAAcmR,IAC9BrJ,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAeyE,SAAU,CAAEzF,OAAMmR,cAAc,CAAEvQ,MAAO+F,KAWhF0K,uBAAwB,CACtBC,EACAL,EACAC,EACAC,IAEArJ,EACEpB,EAAIqB,WAAWC,KACbhH,EAAe0E,OACf,CAAE4L,qBAAoBL,YAAWC,UAASC,cAC1C,CAAEvQ,MAAO+F,KAYf4K,yBAA0B,CACxBvR,EACAiR,EACAE,IAEArJ,EACEpB,EAAIqB,WAAWC,KACbhH,EAAe2E,SACf,CAAE3F,OAAMiR,YAAWE,cACnB,CAAEvQ,MAAO+F,KASf6K,gBAAkBlL,GAChBwB,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAe4E,SAAU,CAAEU,aAAa,CAAE1F,MAAO+F,KAQzEJ,gBAAkBD,GAChBwB,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAe6E,SAAU,CAAES,aAAa,CAAE1F,MAAO+F,KAQzE8K,4BAA8BC,GAC5B5J,EACEpB,EAAIqB,WAAWC,KACbhH,EAAe8E,kBACf,CAAE4L,aACF,CAAE9Q,MAAO+F,KASfZ,aACE4L,GAEA7J,EACEpB,EAAIqB,WAAWC,KACbhH,EAAe+E,aACf,CAAE4L,mBACF,CAAE/Q,MAAO+F,KAEV1H,GAASA,EAAK0S,kBAUnBC,aAAc,CACZ3L,EACAqL,EACAL,IAEAnJ,EACEpB,EAAIqB,WAAWC,KACbhH,EAAegF,IACf,CAAEC,WAAUqL,qBAAoBL,aAChC,CAAErQ,MAAO+F,KAEV1H,GAASA,EAAKiH,UAQnB2L,kBAAoB5L,GAClB6B,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAeiF,SAAU,CAAEA,YAAY,CAAErF,MAAO+F,KACnE1H,GAASA,EAAKqH,YAQnBwL,iBAAmB5L,GACjB4B,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAekF,QAAS,CAAEA,WAAW,CAAEtF,MAAO+F,KACjE1H,GAASA,EAAKqH,YAQnByL,oBAAsBC,GACpBlK,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAemF,UAAW,CAAE6L,UAAU,CAAEpR,MAAO+F,KAClE1H,GAASA,EAAKqH,YAQnBF,YAAc6L,GACZnK,EACEpB,EAAIqB,WAAWC,KACbhH,EAAeoF,YACf,CAAE6L,MAAOA,EAAQA,EAAMC,UAAY,GACnC,CAAEtR,MAAO+F,KAEV1H,GAASA,MCjOVkT,EAAqB,CAACzL,EAAcC,KAA4B,CACpEyL,sBACE7S,UAEA,OAAAuI,EACEpB,EAAIqB,WAAWC,KACbhH,EAAwBmD,0CAEnB5E,GAAO,CACV8S,gBAASlU,EAAAoB,EAAQ8S,0BAEnB,CAAEzR,MAAO+F,IAEZ,EACH2L,sBACE/S,UAEA,OAAAuI,EACEpB,EAAIqB,WAAWC,KACbhH,EAAwBoD,0CAEnB7E,GAAO,CACV8S,gBAASlU,EAAAoB,EAAQ8S,0BAEnB,CAAEzR,MAAO+F,IAEZ,EACH4L,sBACEhT,GAEAuI,EACEpB,EAAIqB,WAAWC,KACbhH,EAAwBqD,WAAUhE,OAAAC,OAAA,GAC7Bf,GACL,CAAEqB,MAAO+F,KAGf6L,sBACEjT,GAEAuI,EACEpB,EAAIqB,WAAWC,KACbhH,EAAwBsD,WAAUjE,OAAAC,OAAA,GAC7Bf,GACL,CAAEqB,MAAO+F,KAGfrF,OAAS2K,GACPnE,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAwBM,OAAQ,CAAE2K,MAAM,CAAErL,MAAO+F,KAEzEnF,KAAOyK,GACLnE,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAwBQ,KAAM,CAC/CyH,YAAa,CAAEgD,MACfrL,MAAO+F,KAER1H,GAASA,IAEd+E,QAAS,IACP8D,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAwBgD,QAAS,CAClDpD,MAAO+F,KAER1H,GAASA,EAAKwT,SCzEfC,EAAe,CAAChM,EAAcC,KAA4B,CAC9DkG,YAAclC,GACZ7C,EACEpB,EAAIqB,WAAWjI,IAAIkB,EAAkB+C,SAAU,CAC7CkF,YAAa,CAAE0B,YACf/J,MAAO+F,KAER1H,GAASA,IAEd6N,kBAAmB,CAACnC,EAAkB5G,IACpC+D,EACEpB,EAAIqB,WAAWC,KACbhH,EAAkB+C,SACb1D,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAyD,GAAU,CAAA4G,aACf,CACE/J,MAAO+F,OCfXgM,EAAU,CAACjM,EAAcC,KAA4B,CAQzDiK,WAAavK,GACXyB,EAAkBpB,EAAIqB,WAAWC,KAAKhH,EAAaqF,OAAQA,EAAQ,CAAEzF,MAAO+F,KAM9EmK,aAAc,IACZhJ,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAesE,aAAc,CAAE,EAAE,CAAE1E,MAAO+F,KAQlE6K,gBAAkBlL,GAChBwB,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAasF,UAAW,CAAEsM,OAAQtM,GAAa,CAAE1F,MAAO+F,KAWhFJ,gBAAkBD,GAChBwB,EACEpB,EAAIqB,WAAWC,KACbhH,EAAauF,gBACb,CAAEqM,OAAQtM,GACV,CAAE1F,MAAO+F,KAafH,MAAQF,GACNwB,EACEpB,EAAIqB,WAAWC,KAAKhH,EAAawF,MAAO,CAAEoM,OAAQtM,GAAa,CAAE1F,MAAO+F,KACvE1H,GAASA,EAAK2T,WC9DrB,4CAAe,CACbC,WAAY,UACZC,iBAAkB,UAClBC,eAAgB,UAChBC,iBAAkB,UAClBC,aAAc,UACdC,mBAAoB,UACpBC,qBAAsB,UACtBC,aAAc,aCgBhB,MAAMC,EAAWlV,WAAAwI,cAAEA,EAAa2M,UAAEA,GAASnV,EAAKoV,EAAMlU,EAAAlB,EAArC,+BACf,MAAMqV,EAAUC,EACdpT,OAAAC,OAAAD,OAAAC,OAAA,CAAAoT,MAAAA,GACGH,GAAM,CACTI,YAAWtT,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EACNiT,EAAOI,cACV,qBAAsB,SACtB,8BAAiD,UAAZ,OAAPC,cAAO,IAAPA,aAAO,EAAPA,QAASC,gBAAU,IAAAnV,OAAA,EAAAA,EAAAoV,OAAQ,GACzD,wBAAyB,eAIvBC,UAAEA,EAASC,OAAEA,GAAWT,EAExB5D,EAA6C,CAAA,EAgC7CsE,ECrDe,EAACvN,EAAcC,KAA4B,CAChEsB,KAAMxB,EAASC,EAAKC,GACpBuN,QAAStI,EAAYlF,EAAKC,GAC1BwN,UAAW5E,EAAc7I,EAAKC,GAC9BjG,OAAQ0L,EAAW1F,EAAKC,GACxByN,eAAgBjC,EAAmBzL,EAAKC,GACxC0N,IAAKtG,EAAgBrH,EAAKC,GAC1BuG,IAAKD,EAAQvG,EAAKC,GAClB2N,WAAYhH,EAAe5G,EAAKC,GAChC+E,SAAUgH,EAAahM,EAAKC,GAC5B2I,KAAM5B,EAAShH,EAAKC,GACpB4N,MAAO3G,EAAUlH,EAAKC,GACtBoJ,KAAMH,EAASlJ,EAAKC,GACpBuJ,MAAOD,EAAUvJ,EAAKC,GACtB6N,MAAOrE,EAAUzJ,EAAKC,GACtB8N,MAAO9D,EAAUjK,EAAKC,GACtB+N,IAAK/B,EAAQjM,EAAKC,KDqCCgO,CAAenB,EAAS7M,GAErCD,iCACD8M,GAAO,CAGVoB,QAAS7V,MAAO6B,GAAmB4S,EAAQoB,QAAQhU,GAOnDqT,aAGAlV,aAAa8V,GACX,KAAKA,aAAA,EAAAA,EAAQC,KAAK,MAAMC,MAAM,gCAE9B,GAAIpF,EAAKkF,EAAOC,KAAM,OAAOnF,EAAKkF,EAAOC,KAKzC,GAFAzU,OAAOC,OAAOqP,OAnDA5Q,WAChB,GAAIuU,EACF,IACE,MAAM0B,EAAYC,KAAKC,MAAM5B,GACvB5D,QAAYyF,EAAUH,GAC5B,MAAO,CACL,CAACA,EAAUF,KAAMpF,EAKpB,CAHC,MAAO0F,GAEP,MADApB,SAAAA,EAAQqB,MAAM,0CAA2CD,GACnD,IAAIL,MAAM,sCAAsCK,IACvD,CAGH,MAGME,SAHoB9B,EAAQzL,WAC/BjI,IAAI,WAAWiU,KACfwB,MAAMvW,GAASA,EAAKwW,UACe7F,KACtC,OAAK9O,MAAMC,QAAQwU,UACQG,QAAQC,IACjCJ,EAAW3M,KAAI5J,MAAO2Q,GAAQ,CAACA,EAAIoF,UAAWK,EAAUzF,QAGtCiG,QAClB,CAACC,GAAMd,EAAKe,KAAUf,EAAWzU,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAsV,IAAK,CAACd,EAAIgB,YAAaD,IAAQD,GAChE,CAAE,GAPmC,EAQtC,EAyB2BG,KAErBpG,EAAKkF,EAAOC,KAAM,MAAMC,MAAM,gCAEnC,OAAOpF,EAAKkF,EAAOC,IACpB,EAOD/V,kBAAkBmO,SAEhB,MACMtM,SADYoV,EAAU9I,EAAKxG,EAAIuP,OAAQ,CAAEC,eAAgB,KAC7CC,QAElB,GAAIvV,IACFA,EAAMwV,IAAe,QAATjY,EAAAyC,EAAMwV,WAAG,IAAAjY,OAAA,EAAAA,EAAEkY,MAAM,KAAKC,MAC9B1V,EAAMwV,MAAQrC,GAEhB,MAAM,IAAIwC,EAAOC,yBACf,+BACA,MACA,gBAKN,MAAO,CAAEtJ,MAAKtM,QACf,EAOD7B,sBAAsB0X,GACpB,IAAKA,EAAc,MAAM1B,MAAM,4CAE/B,IAEE,aADoBrO,EAAIgQ,YAAYD,EAMrC,CAJC,MAAOpB,GAGP,MADArB,SAAAA,EAAQqB,MAAM,4BAA6BA,GACrCN,MAAM,qCAAqCM,IAClD,CACF,EAODtW,qBAAqB4X,WACnB,IAAKA,EAAc,MAAM5B,MAAM,kDAE/B,UACQrO,EAAIgQ,YAAYC,GACtB,MAAMC,QAAgBlQ,EAAIkO,QAAQ+B,GAClC,GAAIC,EAAQC,GAAI,CAEd,aADoBnQ,EAAIgQ,YAA0B,QAAdvY,EAAAyY,EAAQ3X,YAAM,IAAAd,OAAA,EAAAA,EAAA2Y,WAEnD,CAED,MAAM/B,MAAmB,QAAbrW,EAAAkY,EAAQvB,aAAK,IAAA3W,OAAA,EAAAA,EAAEqY,aAK5B,CAJC,MAAOC,GAGP,MADAhD,SAAAA,EAAQqB,MAAM,kCAAmC2B,GAC3CjC,MAAM,2CAA2CiC,IACxD,CACF,EAQDjY,gCACE0X,EACAE,GAEA,IAAKF,IAAiBE,EAAc,MAAM5B,MAAM,6CAEhD,IAEE,aADoBrO,EAAIuQ,gBAAgBR,EAKzC,CAHC,MAAOpB,GAEPrB,SAAAA,EAAQkD,IAAI,wCAAwC7B,2BACrD,CAED,OAAO3O,EAAIyQ,eAAeR,EAC3B,EAQD5X,wBACEoV,EACA/I,GAEA,IAAK+I,EAAW,MAAMY,MAAM,gCAE5B,IAAI/V,EACJ,IACEA,QAAa0H,EAAIyN,UAAUiD,SAASjD,EAAW/I,EAIhD,CAHC,MAAOiK,GAEP,MADArB,SAAAA,EAAQqB,MAAM,gCAAiCA,GACzCN,MAAM,8DAA8DM,IAC3E,CAED,MAAMyB,WAAEA,GAAe9X,EAAKC,KAC5B,IAAK6X,EAEH,MADA9C,SAAAA,EAAQqB,MAAM,gDACRN,MAAM,iCAGd,IAEE,aADoBrO,EAAIgQ,YAAYI,EAKrC,CAHC,MAAOzB,GAEP,MADArB,SAAAA,EAAQqB,MAAM,sCAAuCA,GAC/CN,MAAM,kEAAkEM,IAC/E,CACF,EAQDgC,oBAAmB,CAAC7W,EAA8BiN,IACzC/G,EAAI4Q,0BAA0B9W,EAAU,GAAIiN,GASrD8J,sBAAqB,CAAC/W,EAA8BiN,IAC3C/G,EAAI8Q,4BAA4BhX,EAAU,GAAIiN,GAUvD6J,0BACE9W,EACAE,EACA+M,GAGA,GAAI/M,IAAWK,EAA2BP,EAAUE,GAAS,OAAO,EAEpE,MAAM+W,EAAUlX,EAA2BC,EnB7Pb,cmB6P6CE,GAC3E,OAAO+M,EAAYiK,OAAOC,GAASF,EAAQG,SAASD,IACrD,EASDH,4BACEhX,EACAE,EACA+M,GAEA,GAAI/M,IAAWK,EAA2BP,EAAUE,GAAS,MAAO,GAEpE,MAAM+W,EAAUlX,EAA2BC,EnB/Qb,cmB+Q6CE,GAC3E,OAAO+M,EAAYoK,QAAQF,GAASF,EAAQG,SAASD,IACtD,EAQDG,cAAa,CAACtX,EAA8BwG,IACnCN,EAAIqR,oBAAoBvX,EAAU,GAAIwG,GAS/CgR,gBAAe,CAACxX,EAA8BwG,IACrCN,EAAIuR,sBAAsBzX,EAAU,GAAIwG,GAUjD+Q,oBAAoBvX,EAA8BE,EAAgBsG,GAEhE,GAAItG,IAAWK,EAA2BP,EAAUE,GAAS,OAAO,EAEpE,MAAMwX,EAAa3X,EAA2BC,EnBhTtB,QmBgTgDE,GACxE,OAAOsG,EAAM0Q,OAAOpI,GAAS4I,EAAWN,SAAStI,IAClD,EASD2I,sBAAsBzX,EAA8BE,EAAgBsG,GAClE,GAAItG,IAAWK,EAA2BP,EAAUE,GAAS,MAAO,GAEpE,MAAMwX,EAAa3X,EAA2BC,EnB9TtB,QmB8TgDE,GACxE,OAAOsG,EAAM6Q,QAAQvI,GAAS4I,EAAWN,SAAStI,IACnD,IAGH,OAAO6I,EACLzR,EACA,CACE,mBACA,iBACA,mBACA,sBACA,mBACA,uBACA,uBACA,iBACA,gBACA,cACA,yBACA,yBACA,WAEF7H,EACD,EAoBHwU,EAAQ+E,uBnBjX8B,MmBkXtC/E,EAAQgF,uBnBhX8B"}